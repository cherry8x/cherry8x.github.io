<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[消息丢失解决方案]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[消息丢失解决方案前言书接上回，消息被重复消费会产生数据库数据重复插入的问题。同样，消息丢失也是消息在传输过程中可能出现的问题之一，一旦消息在传输过程中发生丢失，就会造成数据库中的数据出错。 在实际应用中，如果使用MQ来传递核心业务消息，如计费、扣费等消息，一旦消息丢失，就可能造成重大经济损失，因此此时必须要确保消息在传递过程中不会丢失。 怎么保证消息不丢失？消息丢失问题可能出现在生产者、MQ、消费者三个环节中的任意一个，接下来分别从这三个环节介绍一下 RabbitMQ 和 Kafka 的消息丢失解决方案 RabbitMQ解决消息丢失 生产者丢失消息这种情况下，可能由于网络问题，生产者将数据发到RabbitMQ的过程中把数据弄丢了。 可以用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务 channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务 channel.txCommit。 1234567891011// 开启事务channel.txSelecttry &#123; // 这里发送消息&#125; catch (Exception e) &#123; channel.txRollback // 这里再次重发这条消息&#125;// 提交事务channel.txCommit 但是，使用事务会增大系统消耗，降低系统吞吐量。所以一般来说，可以在生产者端设置开启 confirm 模式，开启后生产者每次写消息都会分配一个唯一id，写入MQ后MQ会回传一个 ack 消息，告诉生产者我接收成功了。如果 RabbitMQ 未成功处理消息，会回调生产者的 nack 接口，告诉生产者消息接收失败，你可以重试。且生产者可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么生产者可以重发。 事务机制和 confirm 机制最大的不同点在于，事务机制是同步的，提交事务后系统会处于阻塞状态；但是 confirm 机制是异步的，生产者发送消息之后就可以不用管了，继续发送下一个消息，然后之前发送的消息 RabbitMQ 接收了之后会异步回调你的一个接口通知生产者这个消息接收到了。 所以一般使用 confirm 机制避免生产者丢失消息。 RabbitMQ 丢失消息这种情况是 RabbitMQ 把消息弄丢了。为了避免在这个环节出问题，可以开启 RabbitMQ 的持久化，即消息写入后持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢失。除非，RabbitMQ 还没来得及持久化，自己就挂了，可能导致少量数据丢失，但是这种情况发生的概率极低。 开启 RabbitMQ 的持久化分两个步骤： 创建 queue 的时候将其设置为持久化：这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。 第二个是发送消息的时候将消息的 deliveryMode 设置为 2：就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。 必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。 注意，哪怕是 RabbitMQ 开启了持久化机制，也有一种丢消息的可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的数据丢失。 所以，持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。 消费端丢失消息RabbitMQ 如果丢失消息，主要是因为消费者消费消息的时候，刚消费到消息，还没来及处理，结果进程挂了，比如重启机器了，此时 RabbitMQ 误认为消费者已经消费了，就把数据丢了。 这个时候得用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在编码中 ack 一下。这样的话，如果你还没处理完， RabbitMQ 就不会有 ack 。此时 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。 Kafka消费端丢失消息唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。 这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要关闭自动提交 offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。 生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。 Kafka 丢失消息Kafka 中丢消息比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。如果此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，就丢失了一部分数据。 所以此时一般是要求起码设置如下 4 个参数： 给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。 在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。 在 producer 端设置 acks=all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。 在 producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。生产环境按照上述要求配置后，至少在 Kafka broker 端可以保证如果 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。 生产者会不会丢失消息？如果按照上述的思路设置了 acks=all，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，由于设置了 retries=MAX，生产者会自动不断的重试，重试无限次。 总结消息丢失可能发生在生产者、MQ、消费者三个环节中。 RabbitMQ 消息丢失解决方案 在生产者环节使用异步的 confirm 机制； 在MQ环节中使用持久化与 confirm 相结合机制； 在消费者环节通过确保*消费者处理完消息后手动编码 ack *的方式解决消息丢失的问题。 Kafka 消息丢失解决方案 在生产者环节不会丢消息，因为所有 leader 收到消息 + follower 同步消息完成才会确认消息接收成功； 在 Kafka 环节消息丢失： Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。如果此时其他的 follower 刚好还有些数据没有同步完成，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，就丢失了一部分数据。可以通过设置 4 个参数解决。 在消费者环节关闭自动提交 offset，在消费者处理完消息之后自己手动提交 offset。 注：本系列文章是来自中华石杉老师课程的整理和总结。]]></content>
      <categories>
        <category>数据通信</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>RabbitMQ</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微秒级延迟消息中间件-RabbitMQ]]></title>
    <url>%2F2019%2F06%2F25%2F%E5%BE%AE%E7%A7%92%E7%BA%A7%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ%2F</url>
    <content type="text"><![CDATA[概述RabbitMQ 是由 Erlang 语言开发的，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列。 Erlang 是一种通用的并发程序设计语言，它由乔·阿姆斯特朗（Joe Armstrong）在瑞典电信设备制造商爱立信所辖的计算机科学研究室开发，目的是创造一种可以应付大规模并发活动的程序设计语言和运行环境。 特性 响应速度是微秒级，非常快。 轻量级，易于在操作系统和云中部署运行。 有强大的管理插件，方便用户在浏览器中管理RabbitMQ。 不支持分布式，但可以以镜像集群模式保证高可用。 开发社区非常活跃，文档完善，易于后期维护。 快速入门入门程序工作模式生产者发送消息到消息队列中，消费者从队列中获取消息。 搭建基本环境 新建两个工程：生产者和消费者 分别在两个工程中引入依赖 123456789&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp‐client&lt;/artifactId&gt; &lt;version&gt;4.0.3&lt;/version&gt;&lt;!‐‐此版本与spring boot 1.5.9版本匹配‐‐&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐logging&lt;/artifactId&gt;&lt;/dependency&gt; 创建生产者新建生产者类Producer01，基本流程： 创建连接 创建通道 声明队列 发送消息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Producer01 &#123; //队列 private static final String QUEUE = "HelloWorld"; public static void main(String[] args) &#123; //通过连接工厂创建新的连接和MQ建立连接 ConnectionFactory connectionFactory = new ConnectionFactory(); //设置IP connectionFactory.setHost("127.0.0.1"); //设置端口 connectionFactory.setPort(5672); //设置用户名 connectionFactory.setUsername("guest"); //设置密码 connectionFactory.setPassword("guest"); //设置虚拟机，一个MQ服务可以设置多个虚拟机，每个虚拟机相当于一个独立的MQ connectionFactory.setVirtualHost("/"); Connection connection = null; Channel channel = null; try &#123; //建立新连接 connection = connectionFactory.newConnection(); //创建会话通道，生产者和MQ服务所有通信都在Channel通道中完成 channel = connection.createChannel(); //声明队列，如果队列在MQ中没有则要创建 /** * 参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments * param1:队列名称 * param2:是否持久化，如果持久化，MQ重启后队列还在 * param3:exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭则队列自动删除，如果设为true，可用于临时队列的创建 * param4:autoDelete 自动删除。队列不再使用时是否自动删除此队列，如果将此参数和exclusive设置为true，就可以实现临时队列（队列不用了就自动删除） * param5:arguments 参数。可以设置一个队列的扩展参数。如：可设置存活时间 */ channel.queueDeclare(QUEUE, true, false, false, null); //发送消息 //定义消息内容 String message = "Hello你好MQ"; /** * 消息发布方法 * param1：Exchange的名称，如果没有指定，则使用Default Exchange（设置为""） * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列，如果使用默认交换机，routingKey设置为队列名称 * param3:消息包含的属性 * param4：消息体 */ channel.basicPublish("", QUEUE, null, message.getBytes()); System.out.println("Message has been sent to RabbitMQ: " + message); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭连接 try &#123; channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; try &#123; connection.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 控制台输出发送消息成功 RabbitMQ控制平台可以看到新建的Queue 可以看到待发送消息1条 可以在这里获取消息内容 创建消费者新建消费者类Consumer01，基本流程： 创建连接 创建通道 声明队列 监听队列 接收消息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Consumer01 &#123; //队列 private static final String QUEUE = "HelloWorld"; public static void main(String[] args) throws Exception &#123; //通过连接工厂创建新的连接和MQ建立连接 ConnectionFactory connectionFactory = new ConnectionFactory(); //设置IP connectionFactory.setHost("127.0.0.1"); //设置端口 connectionFactory.setPort(5672); //设置用户名 connectionFactory.setUsername("guest"); //设置密码 connectionFactory.setPassword("guest"); //设置虚拟机，一个MQ服务可以设置多个虚拟机，每个虚拟机相当于一个独立的MQ connectionFactory.setVirtualHost("/"); //建立新连接 Connection connection = connectionFactory.newConnection(); //创建会话通道，生产者和MQ服务所有通信都在Channel通道中完成 Channel channel = connection.createChannel(); //声明队列 channel.queueDeclare(QUEUE, true, false, false, null); //实现消费方法 DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123; /** * 当接收到消息后，此方法将被调用 * @param consumerTag 消费者标签，用来标识消费者，可以在监听队列时设置channel.basicConsume() * @param envelope 信封，消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * @param properties 消息属性 * @param body 消息内容 * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //交换机 String exchange = envelope.getExchange(); //消息id，MQ在channel中用来标识消息的id，用于确认消息已接收 long deliveryTag = envelope.getDeliveryTag(); //消息内容 String message = new String(body, "utf-8"); System.out.println("Message has been received: "+message); &#125; &#125;; //监听队列 /** * 监听队列方法 basicConsume * 参数：String queue, boolean autoAck,Consumer callback * 1、队列名称 * 2、是否自动回复，设置为true为表示消息接收到自动向MQ回复接收到了，MQ接收到回复会删除消息，设置为false则需要通过编码实现回复 * 3、消费消息的方法，消费者接收到消息后调用此方法 */ channel.basicConsume(QUEUE,true,defaultConsumer); &#125;&#125; 控制台输出接收消息成功 消息已被消费，MQ中剩余0条消息 工作模式Work queues（工作队列）与入门程序相比，Work queues 由多个消费者共同分担队列中的任务，RabbitMQ采用轮询的方式将消息依次发送给不同消费者 在入门程序中启动三个消费者（开启顺序为1、2、3），当生产者第一次发送消息，消费者1会收到消息，第二次发送时消费者2收到消息，第三次发送时消费者3收到消息，第四次发送又是消费者1收到消息，以此类推。 Publish/Subscribe（发布订阅）与工作队列相比，Pub/Sub 模式多了交换机，当生产者发送消息时，会先发送消息给交换机，由交换机将消息转发到各个队列中，消费者通过监听自己队列的方式获取消息。 在Work queues 中，生产者发出消息后，消费者只能依次接收到消息。而Pub/Sub模式中，多个消费者可以同时接收到消息，类似广播。 使用编码的方式实现Pub/Sub模式举个栗子：当用户完成充值后，以邮件和短信两种方式通知 生产者：声明交换机 Exchange_fanout_inform 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Producer02_publish &#123; //队列名称 private static final String QUEUE_INFORM_EMAIL = "queue_inform_email"; private static final String QUEUE_INFORM_SMS = "queue_inform_sms"; private static final String EXCHANGE_FANOUT_INFORM="exchange_fanout_inform"; public static void main(String[] args) &#123; //通过连接工厂创建新的连接和MQ建立连接 ConnectionFactory connectionFactory = new ConnectionFactory(); //设置IP connectionFactory.setHost("127.0.0.1"); //设置端口 connectionFactory.setPort(5672); //设置用户名 connectionFactory.setUsername("guest"); //设置密码 connectionFactory.setPassword("guest"); //设置虚拟机，一个MQ服务可以设置多个虚拟机，每个虚拟机相当于一个独立的MQ connectionFactory.setVirtualHost("/"); Connection connection = null; Channel channel = null; try &#123; //建立新连接 connection = connectionFactory.newConnection(); //创建会话通道，生产者和MQ服务所有通信都在Channel通道中完成 channel = connection.createChannel(); //声明队列，如果队列在MQ中没有则要创建 channel.queueDeclare(QUEUE_INFORM_EMAIL, true, false, false, null); channel.queueDeclare(QUEUE_INFORM_SMS, true, false, false, null); //声明一个交换机 String exchange, String type /** * 参数明细 * 1、交换机名称 * 2、交换机类型， * fanout：对应RabbitMQ的工作模式 pub/sub * topic：对应 topic * direct：对应 routing * headers：对应 headers */ channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT); //交换机和队列绑定String queue, String exchange, String routingKey /** * 参数明细 * 1、queue 队列名称 * 2、exchange 交换机名称 * 3、routingKey 路由key，作用是交换机根据路由Key的值将消息转发到指定队列，在Pub/Sub模式中调协为空字符串 */ channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_FANOUT_INFORM,""); channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_FANOUT_INFORM,""); //发5条消息 for (int i = 0; i &lt; 5; i++) &#123; //发送消息 //定义消息内容 String message = "Send inform message to user"; channel.basicPublish(EXCHANGE_FANOUT_INFORM, "", null, message.getBytes()); System.out.println("Message has been sent to RabbitMQ: " + message); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭连接:代码略 &#125; &#125;&#125; 邮件通知消费者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Consumer02_subscribe_email &#123; //队列名称 private static final String QUEUE_INFORM_EMAIL = "queue_inform_email"; private static final String EXCHANGE_FANOUT_INFORM="exchange_fanout_inform"; public static void main(String[] args) throws Exception &#123; //通过连接工厂创建新的连接和MQ建立连接 ConnectionFactory connectionFactory = new ConnectionFactory(); //设置IP connectionFactory.setHost("127.0.0.1"); //设置端口 connectionFactory.setPort(5672); //设置用户名 connectionFactory.setUsername("guest"); //设置密码 connectionFactory.setPassword("guest"); //设置虚拟机，一个MQ服务可以设置多个虚拟机，每个虚拟机相当于一个独立的MQ connectionFactory.setVirtualHost("/"); //建立新连接 Connection connection = connectionFactory.newConnection(); //创建会话通道，生产者和MQ服务所有通信都在Channel通道中完成 Channel channel = connection.createChannel(); //声明队列 channel.queueDeclare(QUEUE_INFORM_EMAIL, true, false, false, null); //声明一个交换机 String exchange, String type /** * 参数明细 * 1、交换机名称 * 2、交换机类型， * fanout：对应RabbitMQ的工作模式 pub/sub * topic：对应 topic * direct：对应 routing * headers：对应 headers */ channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT); //交换机和队列绑定String queue, String exchange, String routingKey /** * 参数明细 * 1、queue 队列名称 * 2、exchange 交换机名称 * 3、routingKey 路由key，作用是交换机根据路由Key的值将消息转发到指定队列，在Pub/Sub模式中调协为空字符串 */ channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_FANOUT_INFORM,""); //实现消费方法 DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //交换机 String exchange = envelope.getExchange(); //消息id，MQ在channel中用来标识消息的id，用于确认消息已接收 long deliveryTag = envelope.getDeliveryTag(); //消息内容 String message = new String(body, "utf-8"); System.out.println("Message has been received: "+message); &#125; &#125;; //监听队列 channel.basicConsume(QUEUE_INFORM_EMAIL,true,defaultConsumer); &#125;&#125; 短信通知消费者（代码略，同邮件消费者） 打开管理平台，使用生产者发5条消息，再依次打开邮件消费者和短信消费者，发现两者都接收到5条消息。如果打开2个邮件消费者，1个短信消费者，再用生产者发5条消息，则结果是短信消费者收到5条消息，2个邮件消费者1个收到3条，1个收到2条消息。 结论： Pub/Sub 模式中，交换机绑定多个队列，每个消费者会监听自己的队列获取消息 如果多个消费者监听同一个队列，则按 Work queues 模式轮询获取消息 Routing（路由）与发布订阅模式相比，Routing 模式下，交换机绑定队列时，每个队列会指定一个 routingKey，而且一个队列可以指定多个 routingKey。生产者发送消息时，交换机会根据 routingKey 是否匹配来转发消息到指定的队列。 以下图为例，如果生产者发出的 routingKey 为 error，两个队列绑定交换机时都设定了 error 这个值，则消息会分别发送到这两个队列中；如果生产者发出的 routingKey 为 warning，那么由于消费者1绑定交换机时未指定这个 routingKey，无法匹配，而消费者2中指定了 warning 这个 routingKey，所以消息只会发送到下面的队列中。最终，消息只能被消费者2接收到。 由于 Routing 模式与 Pub/Sub 模式代码相似，只是增加了 routingKey 的设置，在此不赘述。最终可以在控制台看到设置的 routingKey Topic（通配符）与 Routing 不同，通配符模式 routingKey 匹配方式允许通配符，Routing 模式是相等匹配，Topic 模式是通配符匹配。 统配符规则：符号#可以匹配多个词（词之间用.分割），符号*可以匹配一个词语。 Header（键值对匹配）Header模式与 Routing 的不同，Header 模式取消 routingKey，使用 Header 中的 key/value 匹配队列。Header 实际上是以 Map 结构存储的。 RPC（Remote Procedure Call 远程过程调用）RPC 是客户端远程调用服务端的工作模式 ，使用MQ可以实现RPC的异步调用，是基于Direct交换机实现的。具体实现方式如下： 客户端既是生产者又是消费者，向 RPC 请求队列发送 RPC 调用消息（图中 rpc_queue 即 RPC 请求队列），同时监听RPC响应队列（图中 reply_to 即 RPC 响应队列） 服务端监听 RPC 请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果 服务端将 RPC 方法的结果发送到 RPC 响应队列 客户端（RPC 调用方）监听 RPC 响应队列，接收到 RPC 调用结果 Spring Boot 整合 RabbitMQ用 Spring Boot 整合 RabbitMQ 实现 Topic 模式消息发送 搭建基本环境添加起步依赖，即可自动添加 spring-rabbit 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐amqp&lt;/artifactId&gt;&lt;/dependency&gt; 创建配置文件在主配置文件 application.yml 中配置连接参数 1234567891011server: port: 44000spring: application: name: test‐rabbitmq‐producer rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest virtualHost: / 定义一个 RabbitConfig 类，配置 Exchange，Queue，并绑定交换机 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configurationpublic class RabbitmqConfig &#123; public static final String QUEUE_INFORM_EMAIL = "queue_inform_email"; public static final String QUEUE_INFORM_SMS = "queue_inform_sms"; public static final String EXCHANGE_TOPICS_INFORM="exchange_topics_inform"; /** * 交换机配置 * ExchangeBuilder提供了fanout、direct、topic、header交换机类型的配置 * @return the exchange */ @Bean(EXCHANGE_TOPICS_INFORM) public Exchange EXCHANGE_TOPICS_INFORM() &#123; //durable(true)持久化，消息队列重启后交换机仍然存在 return ExchangeBuilder.topicExchange(EXCHANGE_TOPICS_INFORM).durable(true).build(); &#125; //声明队列 @Bean(QUEUE_INFORM_SMS) public Queue QUEUE_INFORM_SMS() &#123; Queue queue = new Queue(QUEUE_INFORM_SMS); return queue; &#125; //声明队列 @Bean(QUEUE_INFORM_EMAIL) public Queue QUEUE_INFORM_EMAIL() &#123; Queue queue = new Queue(QUEUE_INFORM_EMAIL); return queue; &#125; /** channel.queueBind(INFORM_QUEUE_SMS,"inform_exchange_topic","inform.#.sms.#"); * 绑定队列到交换机 . * * @param queue the queue * @param exchange the exchange * @return the binding */ @Bean public Binding BINDING_QUEUE_INFORM_SMS(@Qualifier(QUEUE_INFORM_SMS) Queue queue, @Qualifier(EXCHANGE_TOPICS_INFORM) Exchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange).with("inform.#.sms.#").noargs(); &#125; @Bean public Binding BINDING_QUEUE_INFORM_EMAIL(@Qualifier(QUEUE_INFORM_EMAIL) Queue queue, @Qualifier(EXCHANGE_TOPICS_INFORM) Exchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange).with("inform.#.email.#").noargs(); &#125;&#125; 生产者使用 spring-rabbit 提供的 RabbitTemplate 模板类中的方法 convertAndSend 进行消息的发送 123456789101112131415@SpringBootTest@RunWith(SpringRunner.class)public class Producer05_topics_springboot &#123; @Autowired RabbitTemplate rabbitTemplate; @Test public void testSendByTopics()&#123; for (int i=0;i&lt;5;i++)&#123; String message = "sms email inform to user"+i; rabbitTemplate.convertAndSend(RabbitmqConfig.EXCHANGE_TOPICS_INFORM, "inform.sms.email",message); System.out.println("Send Message is:'" + message + "'"); &#125; &#125;&#125; 消费者消费端工程加入相同起步依赖，用 spring-rabbit 提供的 @RabbitListener 注解监听队列，且可以监听多个队列。 12345678910111213@Componentpublic class ReceiveHandler &#123; //监听email队列 @RabbitListener(queues = &#123;RabbitmqConfig.QUEUE_INFORM_EMAIL&#125;) public void receive_email(String msg,Message message,Channel channel)&#123; System.out.println("Receive message: " + msg); &#125; //监听sms队列 @RabbitListener(queues = &#123;RabbitmqConfig.QUEUE_INFORM_SMS&#125;) public void receive_sms(String msg,Message message,Channel channel)&#123; System.out.println("Receive message: " + msg); &#125;&#125; 启动生产者，发送消息，消费者工程会自动监听到消息并在控制台输出。 欢迎关注微信公众号，一起交流技术↓ ![{mywechat}](\images\3.jpg)]]></content>
      <categories>
        <category>数据通信</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>消息中间件</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Optional类中orElse和orElseGet方法]]></title>
    <url>%2F2019%2F06%2F25%2FOptional%E7%B1%BB%E4%B8%ADorElse%E5%92%8CorElseGet%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天在开发中使用Optional类避免NPE时遇到一个问题。 使用Optional集合调用isPresent()方法判断集合中是否有值存在，有返回其中的值，否则返回null 1234567public Person getPersonById(String id)&#123; Optional&lt;Person&gt; optional = personRepository.findById(id); if (optional.isPresent())&#123; return optional.get(); &#125; return null; &#125; 问题来了，这时Idea出现黄色警告：Can be replaced with single expression in functional style. 可以被函数式表达式替换，于是我用idea自动修正，代码变成了： 1234public Person getPersonById(String id)&#123; Optional&lt;Person&gt; optional = personRepository.findById(id); return optional.orElse(null);&#125; 打开Optional类源代码，原来orElse方法就是一个三元运算符，如果value不为空返回value，如果为空返回other 12345678910/** * Return the value if present, otherwise return &#123;@code other&#125;. * * @param other the value to be returned if there is no value present, may * be null * @return the value, if present, otherwise &#123;@code other&#125; */public T orElse(T other) &#123; return value != null ? value : other;&#125; 又上网查阅了一下资料，Optional类中还有一个类似的方法orElseGet，源码如下： 12345678910111213/** * Return the value if present, otherwise invoke &#123;@code other&#125; and return * the result of that invocation. * * @param other a &#123;@code Supplier&#125; whose result is returned if no value * is present * @return the value if present otherwise the result of &#123;@code other.get()&#125; * @throws NullPointerException if value is not present and &#123;@code other&#125; is * null */public T orElseGet(Supplier&lt;? extends T&gt; other) &#123; return value != null ? value : other.get();&#125; StackOverFlow中解释两个方法区别的例子： X : buyNewExpensivePhone() called Optional.isPresent() true false findMyPhone(int phoneId).orElse(buyNewExpensivePhone()) X X findMyPhone(int phoneId).orElseGet(() -&gt; buyNewExpensivePhone()) X 结论：当optional.isPresent() == false时，orElse()和orElseGet()没有区别；而当optional.isPresent() == true时，无论你是否需要，orElse始终会调用后续函数。 问题地址：https://stackoverflow.com/questions/33170109/difference-between-optional-orelse-and-optional-orelseget#]]></content>
      <categories>
        <category>代码习惯</category>
      </categories>
      <tags>
        <tag>Issue</tag>
        <tag>jdk1.8</tag>
        <tag>Optional类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息重复消费解决方案]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言在实际生产环境下，消息被消费者重复消费是经常遇到问题之一。如何避免消息被重复消费，是消息队列领域的基本问题，也是在设计系统架构时必须考虑的问题。 RabbitMQ、RocketMQ、Kafka，各种消息中间件都有可能出现消息重复消费的问题，需要开发者来保证消息不被重复消费。 怎么保证消息不被重复消费？（以Kafka为例）生产者在向Kafka写数据时，每条消息会有一个offset，表示消息写入顺序的序号。当消费者消费后，每隔一段时间会把自己已消费消息的offset通过Zookeeper提交给Kafka，告知Kafka自己offset的位置。这样一来，如果消费者重启，则会从Kafka记录的offset之后的数据开始消费，从而避免重复消费。 但是，可能出现一种意外情况。由于消费者提交offset是定期的，当消费者处理了某些消息，但还未来及提交offset时，此时如果重启消费者，则会出现消息的重复消费。 例：数据 1/2/3 依次进入 Kafka，Kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，假设分配的 offset 依次是 152/153/154。消费者从 Kafka 消费时，也是按照这个顺序去消费。假如当消费者消费了 offset=153 的这条数据，刚准备去提交 offset 到 Zookeeper，此时消费者进程被重启了。那么此时消费过的数据1和数据2的 offset 并没有提交，Kafka 也就不知道你已经消费了 offset=153 这条数据。此时当消费者重启后，消费者会找 Kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据1和数据2会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。 如上图，可能出现数据1和数据2插入数据库两遍的问题。 其实重复消费消息并不可怕，重要的是在发生重复消费后，如何保证消息消费时的幂等性。如果消费者可以在消费消息时先判断一下，自己是否已经消费了该消息，如果是就不消费，那么就可以保证系统的幂等性。 一条数据被消费者重复消费两次，但数据库中只有一条数据，这就保证了系统幂等性。 简单来说，保证系统幂等性就是确保消息重复发送后数据库中数据的正确性。 那么，如何保证消息队列的幂等性？ 向数据库insert数据时，先根据主键查询，若数据存在则不insert，改为update 向Redis中写数据可以用set去重，天然保证幂等性 生产者发送每条消息时，增加一个全局唯一id（类似订单id），消费者消费到时，先根据这个id去Redis中查询是否消费过该消息。如果没有消费过，就处理，将id写入Redis；如果消费过了，那么就不处理，保证不重复处理相同消息。 基于数据库的唯一键约束来保证不会插入重复的数据，当消费者企图插入重复数据到数据库时，会报错。 总结 Kafka采取类似断点续传的策略保证消息不被重复消费。具体是通过每隔一段时间把已消费消息的offset通过Zookeeper提交给Kafka实现的。 但是当消费者处理完成但尚未提交offset的时间段宕机或重启等意外情况发生时，还是可能出现消息被重复消费。 保证消息不被重复消费（保证消息消费时的幂等性）其实是保证数据库中数据的正确性。几种保证系统幂等性的思路：通过主键查询，若存在则update；Redis天然set去重；根据全局id查询，若已消费则不处理；唯一键约束保证不插入重复数据等。 注：本系列文章是来自中华石杉老师课程的整理和总结。 欢迎关注微信公众号，一起交流技术↓ ![{mywechat}](\images\3.jpg)]]></content>
      <categories>
        <category>数据通信</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>Kafka</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保证消息队列的高可用性]]></title>
    <url>%2F2019%2F06%2F23%2F%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%2F</url>
    <content type="text"><![CDATA[在实际生产中，引入消息队列技术固然会带来好处，比如降低系统耦合、异步提高响应速度、削平高峰期压力等。然而，任何技术都是一把双刃剑，引入消息队列的同时就要承担一定的风险：系统引入的外部依赖越多，越容易出问题。一旦消息中间件宕机，就会导致整个系统无法使用。因此，保证消息队列的高可用性非常重要。 怎么保证MQ的高可用？RabbitMQ的高可用模式RabbitMQ保证高可用有三种模式：单机模式，普通集群模式，镜像集群模式 单机模式 测试环境下供开发者使用，不适用生产环境 普通集群模式 在集群环境下部署多个MQ，但创建的消息队列（queue）会集中置于一个MQ实例中，其他每个实例同步该消息队列的元数据（可以理解为配置文件，但不是消息本身）。当消费者需要拉取消息时，如果并没有连接到消息队列所在实例，那么该实例会到消息队列所在实例上拉取消息。 普通集群模式的弊端： 可能会在MQ集群内部产生大量数据传输，系统开销较大 可用性较低。一旦queue所在实例挂掉，消息就会丢失，消费者无法正常消费 镜像集群模式 在这种模式下，创建的消息队列无论元数据还是消息队列中的消息都会存在于多个实例上，然后每次当生产者发送消息给MQ实例时，都会自动把消息发送到多个实例的消息队列中进行消息同步。 如何开启镜像集群模式？ 在上一篇文章中提到，RabbitMQ有很好的管理控制台，只需要在后台新增一个镜像集群模式的策略，命令数据同步到所有或指定数量的MQ实例中，当生产者再次创建消息队列时应用这个策略，即可自动同步数据到其他实例中。 镜像集群模式的优势： 高可用。MQ集群中任何一台机器挂了都没事，有备用机器。 镜像集群模式的弊端： 由于RabbitMQ不支持分布式集群，消息队列同步到所有MQ实例会增大网络带宽压力，系统性能开销也相应提高 扩展性不好。无法线性扩展消息队列，一旦在集群中增加机器，就要同步所有消息队列中的数据。 Kafka的高可用模式Kafka集群由多个Kafka实例构成，每个实例被称为broker，每个broker是一个节点；当生产者创建一个topic时，这个topic可以划分为多个partition（区），每个partition可以存在于不同的broker上，每个partition就放一部分数据。 上述模式是天然的分布式消息队列，即一个 topic 的数据，分布在不同的MQ上，每台MQ只放一部分数据。 实际上 RabbmitMQ 不是分布式消息队列，它只是提供了一些集群、HA(High Availability, 高可用性) 机制的传统消息队列。 Kafka 0.8 以前，是没有 HA 机制的，任何一个 broker 宕机了会导致 broker 上的 partition 就挂掉，无法读写，没有什么高可用性可言。 Kafka 0.8 以后，提供了 HA 机制，即 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader **出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 被称为 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要解决数据一致性的问题，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上**，保证了高可用。 如此一来，就保证了消息队列的高可用。每个 broker 中的 partition 在其他机器上都有副本，因此不用担心某个 broker 宕机。如果宕机的 broker 中有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写新的 leader 即可。这就是Kafka实现高可用的模式。 生产者写消息时，生产者就写 leader，然后 leader 将数据写入本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为） 消费者消费消息时，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。 总结本文主要介绍了RabbitMQ和Kafka保证高可用的模式。 RabbitMQ保证高可用有三种模式：普通模式、普通集群模式和镜像集群模式。 其中，普通集群的消息队列只存在于一台机器上，因此当需要拉取消息时，会产生大量数据传输，系统开销大。 相对于普通集群模式，镜像集群模式则把消息队列保存在多台服务器上，虽然保证了高可用但由于只是简单的集群，不是分布式系统，增加了系统开销，且扩展性不好。 Kafka支持分布式，在0.8前没有高可用机制，0.8后提供了 replica 副本机制很好地保证了消息队列的高可用性。每个机器上的partition在其他机器上都有副本，且每个partition都有一个leader，其他机器为follower，生产者和消费者只会在leader上进行读写操作，当leader挂掉时，会重新从follower中选举一个新的leader，不会影响读写。 注：本系列文章是来自中华石杉老师课程的整理和总结。 欢迎关注微信公众号，一起交流技术↓ ![{mywechat}](\images\3.jpg)]]></content>
      <categories>
        <category>数据通信</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>RabbitMQ</tag>
        <tag>Kafka</tag>
        <tag>高可用</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页静态化解决方案-FreeMarker]]></title>
    <url>%2F2019%2F06%2F22%2F%E7%BD%91%E9%A1%B5%E9%9D%99%E6%80%81%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-FreeMarker%2F</url>
    <content type="text"><![CDATA[概述 FreeMarker 是一款模板引擎：即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库（Library），是一款程序员可以嵌入他们所开发产品的组件。 作用：与缓存技术一样，网页静态化技术减轻了数据库访问压力，但应用场景不同。 缓存：适合较小规模数据的场景 网页静态化：适合大规模且数据不经常变化的场景，而且有利于SEO(Search Engine Optimization) 应用：网页静态化解决方案在实际开发中运用比较多。例如新闻网站，门户网站中的新闻频道或者是文章类的频道。 注意：高性能web服务器Nginx适合部署此类纯静态化网页。Nginx可承载五万的并发量，而Tomcat只有几百。 快速入门 引入freemarker依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt; 创建模板 模板文件中四种元素 文本，直接输出的部分 注释，即&lt;#-- ... --&gt;格式不会输出 插值（Interpolation）：即${...}部分,将使用数据模型中的部分替代输出 FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。 创建模板文件test.ftl 12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;FreeMarker快速入门&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;#-- 我是一个注释，我不会输出 --&gt; $&#123;name&#125;,你好。$&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 生成文件 创建Test类main方法 123456789101112131415161718//1.创建配置类Configuration configuration=new Configuration(Configuration.getVersion());//2.设置模板所在的目录 configuration.setDirectoryForTemplateLoading(new File("D:/pinyougou_work/freemarkerDemo/src/main/resources/"));//3.设置字符集configuration.setDefaultEncoding("utf-8");//4.加载模板Template template = configuration.getTemplate("test.ftl");//5.创建数据模型Mapmap=newHashMap();map.put("name", "张三");map.put("message", "欢迎来到神奇的FreeMarker世界！");//6.创建Writer对象Writer out =new FileWriter(new File("d:\\test.html"));//7.输出template.process(map, out);//8.关闭Writer对象out.close(); 执行后，在D盘根目录即可看到生成的test.html，打开： 常用指令 assign：插值 插值结果可以是字符串、数字、日期值、布尔值。 当插值结果为字符串时，直接输出表达式结果 当插值结果为数字时，将结果转化为文本输出，可以使用内建字符串函数格式化插值 当插值结果为日期时，将结果转化为文本输出，可以使用内建字符串函数格式化插值 当插值结果为布尔值时，将结果转化为文本输出，可以使用内建字符串函数格式化插值 12&lt;#assign prchen="hello"/&gt; $&#123;prchen&#125; 输出结果是hello include：引入 include指令类似于JSP的include指令，用来引入指定的页面，提高代码复用性，格式如下： 1&lt;#include filename [options]&gt; 其中参数的意义： filename：该参数指定被包含的模板文件options：该参数可以省略，指定包含时的选项，包含encoding和parse两个选项，其中encoding指定包含页面时所用的解码集，而parse指定被包含文件是否作为FTL文件来解析，如果省略了parse选项值，则该选项默认是true。 if：判断 判断流程分支指令，和Java语言中if判断类似，格式如下 12345&lt;#if condition1&gt;... &lt;#elseif condition2&gt;... &lt;#elseif condition3&gt;... &lt;#else&gt; ... &lt;/#if&gt; list：遍历例：遍历 Student 数据模型中学生信息的三种方式 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt;遍历数据模型中的list学生信息（数据模型中的名称为stus） &lt;table&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;金额&lt;/td&gt; &lt;#--&lt;td&gt;出生日期&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;#list stus as stu&gt; &lt;tr&gt; &lt;td&gt;$&#123;stu_index+1&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.money&#125;&lt;/td&gt; &lt;#--&lt;td&gt;$&#123;stu.birthday&#125;&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/table&gt;&lt;br/&gt;遍历数据模型中的stuMap（map数据），&lt;br/&gt; 第一种方法：在中括号中填写map的key&lt;br/&gt; 姓名：$&#123;stuMap['stu1'].name&#125;&lt;br/&gt; 年龄：$&#123;stuMap['stu1'].age&#125;&lt;br/&gt; 第二种方法：在map后面直接加"点key"&lt;br/&gt; 姓名：$&#123;stuMap.stu1.name&#125;&lt;br/&gt; 年龄：$&#123;stuMap.stu1.age&#125;&lt;br/&gt; 第三种方法：遍历map中的key。stuMap?keys就是key列表（是一个list） &lt;br/&gt;&lt;#list stuMap?keys as k&gt; $&#123;k&#125;&lt;br/&gt; 姓名：$&#123;stuMap[k].name&#125;&lt;br/&gt; 年龄：$&#123;stuMap[k].age&#125;&lt;br/&gt;&lt;/#list&gt;&lt;/body&gt; 内建函数 格式：变量+?+函数名称 获取集合大小：size 1共 $&#123;goodsList?size&#125; 条记录 转换JSON字符串为对象：eval 123&lt;#assign text="&#123;'bank':'工商银行','account':'10101920201920212'&#125;" /&gt;&lt;#assign data=text?eval /&gt;开户行：$&#123;data.bank&#125; 账号：$&#123;data.account&#125; 日期格式化：date，time，datetime，string(&quot;pattern&quot;) 1map.put("today", new Date()); 1234&lt;!--当前日期--&gt; $&#123;today?date&#125; &lt;br&gt;&lt;!--当前时间--&gt; $&#123;today?time&#125; &lt;br&gt;&lt;!--当前日期+时间--&gt; $&#123;today?datetime&#125; &lt;br&gt;&lt;!--日期格式化--&gt; $&#123;today?string("yyyy年MM月")&#125; 数字转换为字符串：c 1&lt;!--累计积分--&gt; $&#123;point?c&#125; 判断变量是否存在：??用法为:variable??,如果该变量存在,返回 true,否则返回 false 12345&lt;#if aaa??&gt; aaa 变量存在&lt;#else&gt; aaa 变量不存在&lt;/#if&gt; 缺失变量默认值：!可以使用!对 null 值做转换处理，在模板文件中加入${aaa!&#39;aaa未被赋值&#39;}，则在代码中不对 aaa 赋值，也不会报错 ，当 aaa 为 null 则返回!后边的内容”aaa未被赋值” 逻辑运算符 逻辑与:&amp;&amp; 逻辑或:|| 逻辑非:! 注意：逻辑运算符只能作用于布尔值,否则将产生错误 比较运算符 =或者==:判断两个值是否相等. !=:判断两个值是否不等. &gt;或者 gt:判断左边值是否大于右边值 &gt;=或者 gte:判断左边值是否大于等于右边值 &lt;或者 lt:判断左边值是否小于右边值 &lt;=或者 lte:判断左边值是否小于等于右边值 注意：=和!=可以用于字符串，数值和日期来比较是否相等，但=和!=两边必须是相同类型的值，否则会产生错误,而且 FreeMarker 是精确比较，”x”,”x “,”X”是不等的。其它的运行符可以作用于数字和日期，但不能作用于字符串，大部分的时候，使用gt等字母运算符代替&gt;会有更好的效果，因为 FreeMarker 会把&gt;解释成 FTL 标签的结束字符，当然，也可以使用括号来避免这种情况，如:&lt;#if (x&gt;y)&gt; 扫一扫，关注我的微信公众号↓]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>FreeMarker</tag>
        <tag>网页静态化</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列总结]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言在近年来的互联网企业面试中，消息队列的出场率越来越高。而在实际工作中，我们不仅要知道怎么使用消息队列，更应该去思考为什么要使用消息队列，消息队列的优缺点是什么以及如果我来设计系统架构，我会选择使用哪一种消息中间件。这也是Java工程师成长为架构师的必由之路。 你为什么要使用消息队列？解耦未使用消息队列时：有BCD系统依赖A系统，A系统向要给BCD传输数据则必须调用BCD的接口，编写相关代码，此时如果又有E系统需要A发消息，则A必须再编写代码调用E系统接口；同样，如果系统C不需要A发消息了，则A又要修改相关代码…此时系统A与其他系统耦合度高，维护起来非常麻烦。 使用消息队列时：A系统（生产者）只需要发送消息到MQ中，BCDE（消费者）如需要数据就自己去中间件里消费，不需要数据就取消消费即可。通过消息中间件的Pub/Sub模式，系统A与其他系统解耦。 异步不使用消息队列服务器时：用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。 使用消息队列服务器时：用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者从消息队列中获取数据，异步写入数据库，由于消息队列服务器处理速度快于数据库，响应速度大幅提升。 削峰高并发场景下，大量请求涌入系统A，在高峰期对MySQL的瞬时压力达到5000条/s，导致MySQL能承受2000条/s，导致MySQL挂掉，系统A瘫痪。当高峰期过了之后，低峰期并发量很低，系统A几乎又没有任何压力了。 此时，就需要使用MQ来进行削峰。有了MQ后，用户在高峰期的请求压力全部打在MQ上，然后系统A再以2000条/s的速度从MQ中慢慢拉取请求，不超过自己的处理上限，则高峰时段大量请求积压在MQ中，系统A会匀速处理这些请求，只要高峰期一过，系统A就会快速解决掉积压的消息，从而实现削峰。即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。 使用消息队列的缺点？系统可用性降低必须确保MQ的正常运转，MQ一旦发生故障，整个系统瘫痪，非常严重。能力越大责任越大，不仅适用MQ，也适用开发人员。 系统复杂度提高在生产环境下增加了系统复杂性，需要考虑消息重复消费、消息丢失、确保消息传递顺序等问题。 一致性问题当消息没有被消费者正确地消费时，会导致请求和响应的数据总量不一致。 ActiveMQ、RabbitMQ、RocketMQ、Kafka都有什么区别？适合哪些场景？ 吞吐量 可用性 可靠性 功能性 社区活跃度 ActiveMQ 十万级（最低） 高 低概率丢消息 MQ领域功能完备，但不适合大规模吞吐量使用场景 成熟，但不活跃 RabbitMQ 十万级 高 低概率丢消息 基于erlang开发，并发能力很强，延迟微秒级，其他三个都是毫秒级。管理界面友好 高 RocketMQ 百万级 非常高，分布式架构 通过优化可以0丢失 MQ领域功能较完备，分布式，扩展性好 较高 Kafka 百万级 非常高，分布式架构 通过优化可以0丢失 功能较简单，大数据领域的实时计算以及日志采集被大规模使用 高 JMS 和 AMQPJMSJMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。JMS（JAVA Message Service，Java消息服务）API是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。 ActiveMQ 就是基于 JMS 规范实现的。 JMS的消息模型和消息正文格式-请参考这篇文章：点我 AMQPAMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，是跨语言、跨平台的。 RabbitMQ 就是基于 AMQP 协议实现的。 AMQP的消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分； 消息正文格式：仅支持 byte[] 消息类型。 总结系统中引入消息队列的作用主要有以下三点： 解耦：通过消息中间件的Pub/Sub模式，使系统解耦，提高了代码的可维护性； 异步：用户请求到达消息队列后就返回，返回的同时消费者消费消息，对数据库进行操作，提升了系统响应速度； 削峰：减轻数据库在高并发场景下的压力，将短时间高并发产生的消息存储在消息队列中，并在非高峰期快速处理掉积压消息。 但是，引入消息队列也会带来以下问题： 系统可用性降低：一旦消息中间件宕机，整个系统瘫痪 系统复杂度提高：需要考虑消息重复消费、消息丢失、确保消息传递顺序等问题 数据一致性问题 四种消息中间件总结： ActiveMQ：最早的MQ，现在用的不多了。社区也不活跃。不推荐使用。 RabbitMQ：基于erlang开发，并发能力很强，延迟微秒级。完备的管理界面。适合并发量要求不是很高的场景。开源社区很活跃，出问题易维护。 RocketMQ：阿里出品开源项目，可定制，且有阿里实际业务场景考验。但社区活跃度相对一般，使用需要承担社区黄掉的风险。推荐对技术有自信的公司使用。 Kafka：用Kafka适应大数据领域的实时计算、日志采集等场景，已是业内标准。社区活跃度很高。缺点是有可能消息重复消费，对数据准确度造成轻微影响。 注：本系列文章是来自中华石杉老师课程的整理和总结。]]></content>
      <categories>
        <category>数据通信</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>RabbitMQ</tag>
        <tag>Kafka</tag>
        <tag>JMS</tag>
        <tag>AMQP</tag>
        <tag>ActiveMQ</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《阿里巴巴Java开发手册》要点整理]]></title>
    <url>%2F2019%2F06%2F12%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[别人都说我们是搬砖的码农，可我们知道自己是追求个性的艺术家。也许我们不会过多在意自己的外表和穿着，但在我们不羁的外表下，骨子里追求着代码的美、系统的美，代码规范其实就是一个对程序美的定义。 声明：本文是对阿里巴巴Java开发手册 v1.4.0 的一个整理。其中去掉了IDE可以帮助我们实现的部分，只整理出个人认为较为重要但在实际开发中易被忽略的点。 编程规约 POJO 类中布尔类型的变量，都不要加 is 前缀 ，否则部分框架解析会引起序列化错误。反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是isDeleted() ， RPC框架在反向解析的时候，“误以为”对应的属性名称是 deleted ，导致属性获取不到，抛出异常。 Service/DAO 层方法命名前缀： 1) 获取单个对象用 get，多个对象用 list。如：listObjects 2) 获取统计值用 count 3) 插入用 save/insert，删除用 remove/delete，修改用update 领域模型命名规约： 1) 数据对象： xxxDO ， xxx 即为数据表名。 2) 数据传输对象： xxxDTO ， xxx 为业务领域相关的名称。 3) 展示对象： xxxVO ， xxx 一般为网页名称。 4) POJO 是 DO / DTO / BO / VO 的统称，禁止命名成 xxxPOJO 。 不允许任何魔法值直接出现在代码中。 魔法值（魔法数字），在编程领域指的是莫名其妙出现的数字。数字的意义必须通过详细阅读才能推断出来。一般魔法数字都需要使用枚举变量来替换。 反例： 12String key = "Id#prchen_" + tradeId;cache.put(key, value); 正例： 123String PRE_KEY="Id#prchen_"String key = PRE_KEY + tradeId;cache.put(key, value); IDE 的 text file encoding 设置为 UTF -8 ; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式。 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。任何情形，没有必要插入多个空行进行隔开。 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 所有的覆写方法，必须加@ Override 注解。可以准确判断是否覆盖成功。 尽量不用可变参数编程。可变参数必须放置在参数列表的最后。 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 。如&quot;prchen&quot;.equals(object); 所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。 1234567Integer a = 66;Integer b = 66;Integer c = 666;Integer d = 666;System.out.println(a == b);//输出trueSystem.out.println(c == d);//输出false POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。1) 所有的 POJO 类属性必须使用包装数据类型。2) RPC 方法的返回值和参数必须使用包装数据类型。3) 所有的局部变量使用基本数据类型。 禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx() 和 getXxx() 方法。框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到。 慎用 Object 的 clone 方法来拷贝对象。对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现域对象的深度遍历式拷贝。 类成员与方法访问控制从严： 1) 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private 。2) 工具类不允许有 public 或 default 构造方法。3) 类非 static 成员变量并且与子类共享，必须是 protected 。4) 类非 static 成员变量并且仅在本类使用，必须是 private 。5) 类 static 成员变量如果仅在本类使用，必须是 private 。6) 若是 static 成员变量，考虑是否为 final 。7) 类成员方法只供类内部调用，必须是 private 。8) 类成员方法只对继承类公开，那么限制为 protected 。任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。这里作者用了一个很形象的比喻： 思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。 关于 *hashCode 和 equals *的处理：1) 只要重写 equals ，就必须重写 hashCode 。2) 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。3) 如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals 。 使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其 add/remove/clear 方法，否则会抛异常。 asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法，是适配器模式的体现。 JDK 7 版本及以上， Comparator 实现类要满足如下三个条件，不然 Arrays.sort， Collections.sort 会报 IllegalArgumentException 异常。1) x， y 的比较结果和 y ， x 的比较结果相反。2) x &gt; y ， y &gt; z ，则 x &gt; z 。3) x = y ，则 x ， z 比较结果和 y ， z 比较结果相同。 使用 entrySet 遍历 Map 类集合 KV ，而不是 keySet 方式进行遍历。keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value 。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK 8，使用 Map.foreach 方法，foreach 底层就是封装了 entrySet 。 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。 ThreadLocal 无法解决共享对象的更新问题， ThreadLocal 对象建议使用 static 修饰。 关于Javadoc注释：1) 类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用 // xxx方式。2) 所有的抽象方法 （ 包括接口中的方法 ） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。3) 所有的类都必须添加创建者和创建日期。 4) 与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。5) 好的命名、代码结构是自解释的，注释力求精简准确、表达到位。以下注释是万万不可取的： 12// put elephant into fridgeput(elephant, fridge); 后台输送给页面的变量必须加 $!{var} ——中间的感叹号。如果 var 等于 null 或者不存在，那么 ${var} 会直接显示在页面上。 Math.random() 这个方法返回是 double 类型，注意取值的范围 0 ≤ x &lt; 1，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，可以直接使用 Random 对象的 nextInt 或者 nextLong 方法 异常日志 异常不要用来做流程控制，条件控制。异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。 不要在 finally 块中使用 return 。finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 防止 NPE ，是程序员的基本修养，注意 NPE 产生的场景： 1) 返回类型为基本数据类型， return 包装数据类型的对象时，自动拆箱有可能产生 NPE 。 2) 数据库的查询结果可能为 null 。 3) 集合里的元素即使 isNotEmpty ，取出的数据元素也可能为 null 。 4) 远程调用返回对象时，要进行空指针判断，防止 NPE 。 5) Session 中获取的数据可能为 null 。 6) 级联调用 obj.getA().getB().getC(); 易产生NPE。 7) 可以使用 JDK8 的 Optional 类来防止 NPE 问题。 避免出现重复的代码 （Don’t Repeat Yourself），即 DRY 原则。抽取共性方法。 应用中的扩展日志 （ 如打点、临时监控、访问日志等 ） 命名方式：appName_logType_logName.log 。logType :日志类型，如 stats/monitor/access 等 ；logName :日志描述。好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，利于归类查找。 务必在 log4j.xml 中*设置 additivity = false *。防止重复打印日志，浪费磁盘空间。 单元测试 好的单元测试必须遵守 AIR 原则（Automatic, Independent, Repeatable）。单元测试在线上运行时，感觉像空气 （AIR） 一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。 对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。 安全规约 用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。 禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。 表单、 AJAX 提交必须执行 CSRF 安全验证。 CSRF （Cross-site request forgery）跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL ，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中用户参数进行相应修改。 MySQL数据库 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。 小数类型为 decimal ，禁止使用 float 和 double 。 float 和 double 在存储的时候，存在精度损失的问题。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 单表行数超过 500 万行或者单表容量超过 2 GB ，才推荐进行分库分表。三年内数据量达不到这个级别，就不要分库分表。 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 例：对列col1、列col2和列col3建一个联合索引 1KEY test_col1_col2_col3 on test(col1,col2,col3); 联合索引test_col1_col2_col3实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。 1SELECT * FROM test WHERE col1 = 1 AND col2 &lt; 2 AND col3 = 3; 上面这个查询语句执行时会依照最左前缀匹配原则，一直向右匹配直到遇到范围查询（&gt;,&lt;,BETWEEN,LIKE）就停止匹配，即会命中索引(col1, col2)。 利用覆盖索引来进行查询操作，避免回表。 不要使用 count(列名)或 count(常量) 来替代 count(*)。count(*) 会统计值为 NULL 的行，而 count(列名) 不会。 当某一列的值全是 NULL 时， count(col) 的返回结果为 0，但 sum(col) 的返回结果为NULL ，因此使用 sum() 时需注意 NPE 问题。 POJO 类的布尔属性不能加 is ，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。 sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。 工程结构 应用分层：开放接口层、终端显示层、Web层、Service层、Manager层、DAO层、外部接口或第三方平台（如下图） 特别说明， Manager 层是通用业务处理层，作用如下：1) 对第三方平台封装，预处理返回结果及转化异常信息2) 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理3) 与 DAO 层交互，对多个 DAO 的组合复用 设计规约 谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。 系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。 避免如下误解：敏捷开发 = 讲故事 + 编码 + 发布。敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上的必要设计和文档沉淀是需要的。 系统架构设计的目的： 1) 确定系统边界。确定系统在技术层面上的做与不做。 2) 确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。 3) 确定指导后续设计与演化的原则。使后续的子系统或模块设计在规定的框架内继续演化。 4) 确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。 最后，引用作者孤尽在手册中的一句话： 很多编程方式客观上没有对错之分，一致性很重要，可读性很重要，团队沟通效率很重要。有一个理论叫帕金森琐碎定律：一个组织中的成员往往会把过多的精力花费在一些琐碎的争论上。程序员天生需要团队协作，而协作的正能量要放在问题的有效沟通上。个性化应尽量表现在系统架构和算法效率的提升上，而不是在合作规范上进行纠缠不休的讨论、争论，最后没有结论。 扫一扫，关注我的微信公众号↓]]></content>
      <categories>
        <category>代码习惯</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>MySQL</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生苦短，请用Spring Boot]]></title>
    <url>%2F2019%2F06%2F09%2F%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E8%AF%B7%E7%94%A8Spring%20Boot%2F</url>
    <content type="text"><![CDATA[概述 Spring Boot 是一个轻量级框架，它的的目的是提供一组工具，以便快速构建容易配置的 Spring 应用程序。Spring Boot使用户可以“直接运行”独立的、基于生产级的应用程序。这意味着只需极少的配置，就可以快速获得一个正常运行的 Spring 应用程序。 特性 为基于 Spring 的应用程序开发提供更快的入门体验 直接集成Tomcat、Jetty、Undertow等Web容器（不需要部署war包） 提供了自定义的起步依赖，简化pom.xml配置 在合理的情况下自动配置Spring和第三方库 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。 极少的注解配置，绝对不需要XML配置，不需要XML配置，不需要XML配置。重要的事情说三遍。 快速入门 起步依赖 创建 Maven 工程 springBootDemo（打包方式 jar），并在pom.xml中添加起步依赖 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 我们会发现以上 jar 包被自动导入了，而这些正是我们开发时需要导入的 jar 包。 变更 JDK 版本添加jdk版本配置，然后更新工程 123&lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt;&lt;/properties&gt; 引导类 创建引导类 123456789package com.prchen.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 执行引导类main方法，控制台出现以下标识： Spring MVC 实现字符串输出 用过Spring MVC都知道，使用时需要创建web.xml以及springmvc.xml，并配置前端控制器、处理器映射器、处理器适配器以及视图解析器……但是，用了Spring Boot，这一切繁杂的步骤通通都省了！ XML拜拜了您嘞！ 我们可以直接写Controller 12345678910package com.prchen.demo;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/info") public String info() &#123; return "Hello Spring Boot!"; &#125;&#125; 修改 tomcat 启动端口在 src/main/resources 下创建 application.properties，配置端口信息server.port=8089，然后重新运行引导类，地址栏输入http://localhost:8089/info 大功告成！ 读取自定义配置 在 src/main/resources 下的 application.properties 增加配置url=http://www.prchen.com，然后修改Controller 1234567891011@RestControllerpublic class HelloWorldController &#123; @Autowired private Environment env; @RequestMapping("/info") public String info() &#123; return "Hello Spring Boot!" + env.getProperty("url"); &#125;&#125; Spring Boot就会读取自定义配置信息并展示 热部署 在开发中反复修改类、页面等资源，每次修改后都需要重启才能生效，浪费了大量的时间，能不能在修改代码后不重启就能生效呢？能！Spring Boot在pom.xml 中添加如下依赖就可以实现这样的功能，即热部署。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 依赖添加后，重启引导类，然后将配置改为url=http://prchen.com，直接刷新页面，配置的更改即时生效了！ 在Controller类中添加一个方法，不重启引导类，直接刷新页面。 1234@RequestMapping("/info2")public String info2() &#123; return "Hello Spring Boot2!" + env.getProperty("url");&#125; 你看到了什么？没错，刚刚添加的方法也即时生效了~没错就是这么方便 那么，Spring Boot为什么会这么好用呢？ 原理 关于起步依赖 jar 包被引入的spring-boot-starter-web 所引用了，所以我们引用 spring-boot-starter-web 后会自动把依赖传递过来。 关于 @SpringBootApplication 注解 引导类中 @SpringBootApplication 其实是以下三个注解的总和： @Configuration： 用于定义一个配置类 @EnableAutoConfiguration ：Spring Boot 会自动根据 jar 包依赖来自动配置目。 @ComponentScan： 告诉 Spring 哪个包中用注解标识的类会被自动扫描并装入 bean 容器中。 自动配置关键注解 @Configuration&amp;与@Bean-&gt;基于java代码的bean配置 @Conditional-&gt;设置自动配置条件依赖 @EnableConfigurationProperties与@ConfigurationProperties-&gt;读取配置文件转换为bean。 @EnableAutoConfiguration、@AutoConfigurationPackage 与@Import-&gt;实现bean发现与加载。 Spring Boot 整合 ActiveMQ 使用内嵌服务 引入ActiveMQ起步依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; 创建消息生产者 1234567891011@RestControllerpublic class QueueController &#123; @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @RequestMapping("/send") public void send(String text) &#123; jmsMessagingTemplate.convertAndSend("prchen", text); &#125;&#125; 创建消息消费者 1234567@Componentpublic class Consumer &#123; @JmsListener(destination = "prchen") public void getMessage(String text) &#123; System.out.println("接收到消息：" + text); &#125;&#125; 测试：启动服务后，在浏览器执行http://localhost:8089/send?text=abc，控制台输出接收到消息：abc。此时登陆之前配置好的ActiveMQ客户端地址（这里）会发现消息并没有显示，原因是Spring Boot 内置了 ActiveMQ 的服务，所以我们不用单独启动也可以执行应用程序 使用外部服务 在 src/main/resources 下的 application.properties 增加配置, 指定 ActiveMQ 的地址（ip为ActiveMQ服务器所在地址） 1spring.activemq.broker-url=tcp://192.168.25.128:61616 再次发送消息，然后登陆客户端，发现成功接收到消息 发送 Map 消息 QueueController中添加sendMap方法 1234567@RequestMapping("/sendMap") public void sendMap() &#123; Map map = new HashMap&lt;&gt;(); map.put("name", "zhangsan"); map.put("gender", "male"); jmsMessagingTemplate.convertAndSend("prchen", map); &#125; Consumer中添加readMapMessage方法 1234@JmsListener(destination = "prchen_map")public void readMapMessage(Map map) &#123; System.out.println("接收到Map：" + map);&#125; 访问http://localhost:8089/sendMap发送消息，访问客户端，发现消息成功接收 扫一扫，关注我的微信公众号↓]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效的消息中间件-ActiveMQ]]></title>
    <url>%2F2019%2F06%2F04%2F%E9%AB%98%E6%95%88%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-ActiveMQ%2F</url>
    <content type="text"><![CDATA[概述 JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范，它便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。 JMS 本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。它类似于 JDBC(java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。 JMS的优势 间接通信。客户机不直接对话，而是通过消息中间件。 持久性。 JMS的提供者能够持久化存储消息，直到客户机接受到消息。 异步通信。JMS通信是异步的，当客户端获取消息时，不用主动发送请求，消息会自动发送给可用客户端，实现消息的高效传递。 通用性。使用JMS，可以使用相同API访问ActiveMQ、RabbitMQ等消息服务。 JMS消息传递类型点对点（PTP） 一个生产者和一个消费者一一对应 发布订阅（pub/sub） 一个生产者产生消息并进行发送后，可以由多个消费者进行接收。 ActiveMQ快速入门点对点模式 创建生产者QueueProducer 123456789101112131415161718192021222324public class QueueProducer &#123; public static void main(String[] args) throws JMSException &#123; //1.创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.128:61616"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session(会话对象) 参数1：是否启用事务(false为自动commit) 参数2：消息确认模式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建队列对象 Queue queue = session.createQueue("test-queue"); //6.创建消息生产者对象 MessageProducer producer = session.createProducer(queue); //7.创建消息对象（文本消息） TextMessage textMessage = session.createTextMessage("消息对象创建了..."); //8.发送消息 producer.send(textMessage); //9.关闭资源 producer.close(); session.close(); connection.close(); &#125;&#125; 先执行QueueProducer，创建完成后，可以在Queue中看到该消息已暂存在队列中： 创建消费者QueueConsumer 123456789101112131415161718192021222324252627282930313233public class QueueConsumer &#123; public static void main(String[] args) throws JMSException, IOException &#123; //1.创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.128:61616"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session(会话对象) 参数1：是否启用事务(false为自动commit) 参数2：消息确认模式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建队列对象 Queue queue = session.createQueue("test-queue");//注意这里队列名称必须和生产者一样 //6.创建消息消费者对象 MessageConsumer consumer = session.createConsumer(queue); //7.设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println("提取消息中的文本："+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); //8.等待键盘输入 System.in.read(); //9.关闭资源 consumer.close(); session.close(); connection.close(); &#125;&#125; 再执行QueueConsumer，成功取出了队列中的消息： 打开网页客户端，消息被取出： 第二次执行QueueConsumer，无法获取消息： 发布订阅模式 生产者TopicProducer：只需把点对点模式中的Queue对象改为创建Topic对象即可 1234//5.创建主题对象Topic topic = session.createTopic("test-topic");//6.创建消息生产者对象MessageProducer producer = session.createProducer(topic); 先执行生产者，再执行消费者，则无法收到消息 先执行多个消费者，再执行生产者：两个消费者都收到了消息（类似广播） 结论： 发布/订阅模式消费者必须在生产者发出消息的同时接收消息，才能接收到 发布/订阅模式可以有多个执行方法的消费者同时获得消息 点对点模式生产者发出消息后可以暂存在客户端，等待消费者执行方法获取消息 点对点模式只能有一个最早执行方法的消费者获得消息 Spring整合JMS点对点模式 建立springjms_producer工程 导入依赖 1234567891011121314151617181920212223242526 &lt;properties&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; applicationContext-jms-producer.xml配置文件 12345678910111213141516171819202122&lt;context:component-scan base-package="com.wzc.demo"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.128:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; 生产者QueueProducer 1234567891011121314151617181920212223@Componentpublic class QueueProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination queueTextDestination; /** * 发送文本消息 * @param text */ public void sendTextMessage(final String text) &#123; jmsTemplate.send(queueTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125;&#125; 测试类TestQueue 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-producer.xml")public class TestQueue &#123; @Autowired private QueueProducer queueProducer; @Test public void testSend() &#123; queueProducer.sendTextMessage("SpringJMS点对点测试"); &#125;&#125; 运行测试类，可以看到消息队列成功存储： 建立springjms_consumer工程 导入依赖（同生产者） applicationContext-jms-consumer-queue.xml配置文件 123456789101112131415161718192021222324&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.128:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; &lt;!-- 自定义监听类 --&gt;&lt;bean id="myMessageListener" class="com.wzc.demo.MyMessageListener"&gt;&lt;/bean&gt;&lt;!-- 消息监听容器 --&gt;&lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueTextDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt;&lt;/bean&gt; 自定义监听类MyMessageListener，该类要实现MessageListener接口 12345678910public class MyMessageListener implements MessageListener&#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println("收到消息："+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 测试类TestQueue 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-consumer-queue.xml")public class TestQueue &#123; @Test public void testQueue() &#123; try &#123; System.in.read(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行测试类，可以看到消费者成功接收消息： 发布/订阅模式 applicationContext-jms-producer.xml配置文件增加发布订阅模式文本信息 1234&lt;!-- 这个是订阅模式文本信息 --&gt;&lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic_text"/&gt; &lt;/bean&gt; 生产者TopicProducer（同QueueProducer，把Destination对象名中的queue替换为topic） 测试类TestTopic（同TestQueue，把QueueProducer替换为TopicProducer） 运行测试类，成功发送消息 applicationContext-jms-consumer-topic.xml配置文件修改点对点模式为发布订阅模式 12345678910&lt;!--这个是队列目的地，发布订阅的 文本信息--&gt; &lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic_text"/&gt; &lt;/bean&gt; &lt;!-- 消息监听容器 --&gt;&lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="topicTextDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt;&lt;/bean&gt; 测试类TestTopic（修改对应配置文件路径和方法名即可） 启动3个消费者测试类，再执行生产者中的测试类TestTopic，三个消费者测试类同时接收到消息]]></content>
      <categories>
        <category>数据通信</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>JMS</tag>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超好用的Web开发浏览器插件-Web Developer]]></title>
    <url>%2F2019%2F06%2F04%2F%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6-Web%20Developer%2F</url>
    <content type="text"><![CDATA[概述 Web Developer是一款Web开发人员必备的浏览器实用插件，它提供了多种模块让开发人员可以在工具栏中便捷地对网页的HTML、脚本、多媒体、CSS、缓存、图象等网页内容进行调试。Web Developer适用于Chrome，Firefox和Opera浏览器 安装 谷歌浏览器插件商店中搜索”Web Developer”，或者直接点击以下链接（需要kexueshangwang）：https://chrome.google.com/webstore/detail/web-developer/bfbameneiokkgbdmiekhjnmfkcnldhhm?hl=zh-CN 点击添加至Chrome即可安装 安装完成后右上角插件栏会多出一个齿轮图标，点击即用 常用模块及功能介绍由于Web Development功能强大且丰富，笔者只列出其中相对较常用的模块及功能。 Disable Disable JavaScript：禁用JS脚本 Disable Popups：禁用弹出窗口 Reset Disable Features：重置所有禁用选项 Cookies Disable Cookies：禁用Cookies Add Cookie…：添加Cookie，需要填写以下字段信息： Delete Domain Cookies：删除当前域Cookie Delete Session Cookies：删除Session域中所有Cookie View Cookie Information：在新窗口打开当前页面的所有Cookie信息，可以对Cookie进行编辑、删除等操作 CSS Disable All Styles：禁用所有CSS样式 View CSS：在新窗口查看网页CSS Edit CSS：编辑当前网页CSS文件，并即时生效 Forms 该模块提供Form表单相关操作，例如：一键清空表单所有字段，改变表单提交方式post/get相互转化，显示密码，显示表单元素的属性值，表单详细信息等等众多快捷易用的表单操作，在此不再赘述，如需要读者可以亲自试用。 Clear Form Fields：一键清空表单所有字段 Convert Form GETs To POSTs/POSTs To GETs：表单提交方式post转化为get/get转化为post Display Passwords：显示密码 Display Form Details：很实用的功能，打开后直接在网页中显示所有表单元素的详细属性值 View Form Information：在新窗口中浏览表单详细信息Images 图片相关操作 Disable Images：禁用所有图片 Disable Alt Attributes：禁用图片的alt属性 Outline All Images：标识出当前页所有图片 View Image Information：在新窗口中显示当前页面所有图片信息，如：src, width, height, alt属性Infomation Display Link Detalis：直接在网页中显示href属性值 Display Element Information：选择后变为十字光标，可以选择当前网页中任意元素并在网页底部显示详细属性 Find Duplicate Ids：找出所有重复id View Color information：显示网页中所有颜色详细信息 View JavaScript：显示网页JS源代码 View Response Headers：显示网页响应头信息Micellaneous 各种实用功能模块，个人认为此部分功能比较实用 Clear Cache：前端调试时最常用的功能之一，清理缓存的快捷方式 Clear History：快速清理历史记录 Display Color Picker：即点即用的取色器 Display Hidden Elements：显示隐藏元素 Display Ruler：显示标尺 再也不用拿尺子量屏幕了 Mark All Links Unvisited/Visited：将所有链接标记为已访问/未访问的Outline Outline Absolute Positioned Elements：标识出绝对定位（position: absolute）的元素 Outline Block Level Elements：标识块级元素 Outline Deprecated Elements：标识过时元素 Outline Fixed Positioned Elements：标识固定（position: fixed）的元素 Outline Floated Elements：标识悬浮元素 Outline Tables：标识表格Reisize 调节窗口大小，包括可以预览网页在各种设备上的响应式效果 Tools CSS, HTML, 链接等各种校验器以及查看网页源代码 扫一扫，关注我的微信公众号↓]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>前端</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程调用服务好帮手-dubbox]]></title>
    <url>%2F2019%2F06%2F02%2F%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%A5%BD%E5%B8%AE%E6%89%8B-dubbox%2F</url>
    <content type="text"><![CDATA[概述 Dubbox是一款高性能、轻量级的开源Java RPC（Remote Procedure Call 远程过程调用）框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 Dubbox 的前身是阿里巴巴开源项目 Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在 Dubbo 基础上进行优化，并继续维护，为了与原有的 Dubbo 区分，故将其命名为 Dubbox。 角色 注册中心（Registry）：相当于房东、中介，记录提供者和消费者信息 监控中心（Monitor）：通过连接注册中心，监控消费者和提供者健康状况 服务提供者（Provider）：Service层 服务消费者（Consumer）：Web层 四种角色之间的关系如下图 相关概念 远程调用：用@Reference：web调用service，依赖中没有service的jar包，service是war，此时是远程调用 本地调用：用@Autowired：service调用dao，依赖中有dao.jar，此时是本地调用 长连接：建立连接后，不断进行数据交互 短连接：建立连接后，没有操作则自动断开 WebService：远程服务调用API 具体实现： 老：axis, cxf 新：hessain, dubbox, feign Ribbon Ｄubbox的优势Dubbox具有以下优势： 负载均衡：同一个工程划分成不同模块，每个模块部署在独立的服务器上 服务调用链路生成：服务间依赖关系错踪复杂，可以解决服务之间互相是如何调用的 服务访问压力以及时长统计、资源调度和治理：基于访问压力实时管理集群容量，提高集群利用率。 服务降级：某个服务宕机后调用备用服务 可以应用在微服务系统中 快速入门注册中心Zookeeper 上传zookeeper-3.4.6.tar.gz至Linux服务器，并解压 tar -zxvf 创建data文件夹 mkdir /root/zookeeper-3.4.6/data 重命名 /root/zookeeper-3.4.6/conf/zoo_example.cfg 为 zoo.cfg，并使用vim编辑器修改 zoo.cfg 中的 dataDir=/root/zookeeper-3.4.6/data 监控中心 上传 dubbo-admin-2.8.4.war 和 apache-tomcat.tar.gz至Linux服务器，解压tomcat 把 dubbo-admin-2.8.4.war拷贝到 tomcat/webapp 目录下 启动tomcat ./tomcat/bin/startup.sh 在不改变默认端口的情况下，可以通过 虚拟机IP:8080/dubbo-admin访问监控中心，默认用户名密码均为root，实时监控消费者和提供者的健康状况 服务提供者 在Service模块业务层实现类上增加注解@Service ，注意包名是dubbo不是springframework 12345import com.alibaba.dubbo.config.annotation.Service;@Servicepublic class XxxServiceImpl implements XxxService &#123;...&#125; 在spring主配置文件中增加以下配置 123&lt;dubbo:application name="一般和项目名称保持一致，唯一"/&gt; &lt;!--在“注册中心”声明服务提供者名称--&gt;&lt;dubbo:registry address="zookeeper://服务器ip:2181"/&gt; &lt;!--连接注册中心--&gt;&lt;dubbo:annotation package="要暴露服务所在的包路径"/&gt; 服务消费者 在Web模块控制层Controller类中调用Service 12345678import com.alibaba.dubbo.config.annotation.Reference;@RestController@RequestMapping("/xxx")public class XxxController &#123; @Reference private XxxService XxxService; ...&#125; 这样，我们就完成了远程调用Service服务。]]></content>
      <categories>
        <category>数据通信</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>分布式</tag>
        <tag>Dubbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity整理]]></title>
    <url>%2F2019%2F05%2F30%2Fspring-security%2F</url>
    <content type="text"><![CDATA[SpringSecurity简介 Spring Security 是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了Spring IoC，DI（控制反转 Inversion of Control ,DI:Dependency Injection 依赖注入）和 AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。 SpringSecurity 实现登录功能 引入spring-security-web和spring-security-config依赖 创建web.xml，其中定义配置文件spring-security.xml的contextConfigLocation 1234567891011121314151617&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-security.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注意：此步骤中springSecurityFilterChain名称不可自定义，spring框架的底层源码中已定义该名称。 创建配置文件spring-security.xml 12345678910111213&lt;!-- 页面拦截规则 --&gt;&lt;http use-expressions="false"&gt; &lt;intercept-url pattern="/**" access="ROLE_USER" /&gt; &lt;form-login/&gt; &lt;/http&gt;&lt;!-- 认证管理器 --&gt;&lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;user-service&gt; &lt;user name="admin" password="123456" authorities="ROLE_USER"/&gt; &lt;/user-service&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; 配置说明： intercept-url 表示拦截页面（/* 表示的是该目录下的资源，只包括本级目录不包括下级目录；/** 表示的是该目录以及该目录下所有级别子目录的资源） form-login 为开启表单登陆 use-expressions ：是否允许SpEL，默认为 true。当为true时，拦截url应写成如下形式： 1&lt;intercept-url pattern="/**" access="hasRole('ROLE_USER')" /&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端程序员必备的Linux基础知识]]></title>
    <url>%2F2019%2F05%2F28%2Flinux_basic_knowledge%2F</url>
    <content type="text"><![CDATA[学习Linux之前，我们先来简单的认识一下操作系统。 一 从认识操作系统开始1.1 操作系统简介我通过以下四点介绍什么操作系统： 操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石； 操作系统本质上是运行在计算机上的软件程序 ； 为用户提供一个与系统交互的操作界面 ； 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。 1.2 操作系统简单分类 Windows: 目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。 Unix： 最早的多用户、多任务操作系统 .按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。 Linux: Linux是一套免费使用和自由传播的类Unix操作系统.Linux存在着许多不同的Linux版本，但它们都使用了 Linux内核 。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。 二 初探Linux2.1 Linux简介我们上面已经介绍到了Linux，我们这里只强调三点。 类Unix系统： Linux是一种自由、开放源码的类似Unix的操作系统 Linux内核： 严格来说，Linux这个词本身只表示Linux内核 Linux之父： 一个编程领域的传奇式人物。他是Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了Git这个开源项目，并为主要的开发者。 2.2 Linux诞生简介 1991年，芬兰的业余计算机爱好者Linus Torvalds编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统）被ftp管理员命名为Linux 加入到自由软件基金的GNU计划中; Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。 2.3 Linux的分类Linux根据原生程度，分为两种： 内核版本： Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等； 发行版本： 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux发行版本有很多种（ubuntu和CentOS用的都很多，初学建议选择CentOS），如下图所示： 三 Linux文件系统概览3.1 Linux文件系统简介在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。 也就是说在LINUX系统中有一个重要的概念：一切都是文件。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。 3.2 文件类型与目录结构Linux支持5种文件类型 ： Linux的目录结构如下： Linux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录： 常见目录说明： /bin： 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里； /etc： 存放系统管理和配置文件； /home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示； /usr ： 用于存放系统应用程序； /opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里； /proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息； /root： 超级用户（系统管理员）的主目录（特权阶级^o^）； /sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等； /dev： 用于存放设备文件； /mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统； /boot： 存放用于系统引导时使用的各种文件； /lib ： 存放着和系统运行相关的库文件 ； /tmp： 用于存放各种临时文件，是公用的临时文件存储点； /var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等； /lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。 四 Linux基本命令下面只是给出了一些比较常用的命令。推荐一个Linux命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。 Linux命令大全：http://man.linuxde.net/ 4.1 目录切换命令 cd usr： 切换到该目录下usr目录 cd ..（或cd../）： 切换到上一层目录 cd /： 切换到系统根目录 cd ~： 切换到用户主目录 cd -： 切换到上一个操作所在目录 4.2 目录的操作命令(增删改查) mkdir 目录名称： 增加目录 ls或者ll（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息 find 目录 参数： 寻找目录（查） 示例： 列出当前目录及子目录下所有文件和文件夹: find . 在/home目录下查找以.txt结尾的文件名:find /home -name &quot;*.txt&quot; 同上，但忽略大小写: find /home -iname &quot;*.txt&quot; 当前目录及子目录下查找所有以.txt和.pdf结尾的文件:find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)或find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; mv 目录名称 新目录名称： 修改目录的名称（改） 注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。 mv 目录名称 目录的新位置： 移动目录的位置—剪切（改） 注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。 cp -r 目录名称 目录拷贝的目标位置： 拷贝目录（改），-r代表递归拷贝 注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归 rm [-rf] 目录: 删除目录（删） 注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包 4.3 文件的操作命令(增删改查) touch 文件名称: 文件的创建（增） cat/more/less/tail 文件名称 文件的查看（查） cat： 查看显示文件内容 more： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看 less： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看 tail-10 ： 查看文件的后10行，Ctrl+C结束 注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化 vim 文件： 修改文件的内容（改） vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。 在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤： vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。） rm -rf 文件： 删除文件（删） 同目录删除：熟记 rm -rf 文件 即可 4.4 压缩文件的操作命令1）打包并压缩文件： Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。 而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件其中： z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 比如：加入test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt或：tar -zcvf test.tar.gz /test/ 2）解压压缩包： 命令：tar [-xvf] 压缩文件 其中：x：代表解压 示例： 1 将/test下的test.tar.gz解压到当前目录下可以使用命令：tar -xvf test.tar.gz 2 将/test下的test.tar.gz解压到根目录/usr下:tar -xvf xxx.tar.gz -C /usr（- C代表指定解压的位置） 4.5 Linux的权限命令 操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 ls -l 命令我们可以 查看某个目录下的文件或目录的权限 示例：在随意某个目录下ls -l 第一列的内容的信息解释如下： 下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？ 文件的类型： d： 代表目录 -： 代表文件 l： 代表软链接（可以认为是window中的快捷方式） Linux中权限分为以下几种： r：代表权限是可读，r也可以用数字4表示 w：代表权限是可写，w也可以用数字2表示 x：代表权限是可执行，x也可以用数字1表示 文件和目录权限的区别： 对文件和目录而言，读写执行表示不同的意义。 对于文件： 权限名称 可执行操作 r 可以使用cat查看文件的内容 w 可以修改文件的内容 x 可以将其运行为二进制文件 对于目录： 权限名称 可执行操作 r 可以查看目录下列表 w 可以创建和删除目录下文件 x 可以使用cd进入目录 需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。 所有者 一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。 文件所在组 当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组。 其它组 除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组 我们再来看看如何修改文件/目录的权限。 修改文件/目录的权限的命令：chmod 示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，其他用户只有读的权限 chmod u=rwx,g=rw,o=r aaa.txt 上述示例还可以使用数字表示： chmod 764 aaa.txt 补充一个比较常用的东西: 假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？ 新建一个脚本zookeeper 为新建的脚本zookeeper添加可执行权限，命令是:chmod +x zookeeper 把zookeeper这个脚本添加到开机启动项里面，命令是：chkconfig --add zookeeper 如果想看看是否添加成功，命令是：chkconfig --list 4.6 Linux 用户管理Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 Linux用户管理相关命令: useradd 选项 用户名:添加用户账号 userdel 选项 用户名:删除用户帐号 usermod 选项 用户名:修改帐号 passwd 用户名:更改或创建用户的密码 passwd -S 用户名 :显示用户账号密码信息 passwd -d 用户名: 清除用户密码 useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。 4.7 Linux系统用户组的管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 Linux系统用户组的管理相关命令: groupadd 选项 用户组 :增加一个新的用户组 groupdel 用户组:要删除一个已有的用户组 groupmod 选项 用户组 : 修改用户组的属性 4.8 其他常用命令 pwd： 显示当前所在位置 grep 要搜索的字符串 要搜索的文件 --color： 搜索命令，–color代表高亮显示 ps -ef/ps -aux： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：ps aux|grep redis （查看包括redis字符串的进程），也可使用 pgrep redis -a。 注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。 kill -9 进程的pid： 杀死进程（-9 表示强制终止。） 先用ps查找进程，然后用kill杀掉 网络通信命令： 查看当前系统的网卡信息：ifconfig 查看与某台机器的连接情况：ping 查看当前系统的端口使用：netstat -an net-tools 和 iproute2 ： net-tools起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持iproute2。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读如何在Linux中使用IP命令和示例 shutdown： shutdown -h now： 指定现在立即关机；shutdown +5 &quot;System will shutdown after 5 minutes&quot;：指定5分钟后关机，同时送出警告信息给登入用户。 reboot： reboot： 重开机。reboot -w： 做个重开机的模拟（只有纪录并不会真的重开机）。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC整理]]></title>
    <url>%2F2019%2F05%2F05%2FSpring%20MVC%2F</url>
    <content type="text"><![CDATA[MVC概述MVC(Model View Controller)是一种软件设计模式，分为模型，视图，控制器三个部分。 MVC的原理 Spring MVC概述SpringMVC 框架是以请求为驱动，围绕 Servlet 设计，将请求发给控制器，然后通过模型对象，分派器来展示请求结果视图。其中核心类是 DispatcherServlet，它是一个 Servlet，顶层是实现的Servlet接口。 Spring MVC使用在 web.xml 中配置 DispatcherServlet （Spring子容器），并且需要配置 ContextLoaderListener（Spring父容器） 工作原理：Spring MVC的工作流程： 用户发起一个请求 DispatcherServlet 接受用户发出的 request 请求查找 HandlerMapping 解析返回 Handler 请求 HandlerAdapter 执行 Handler 返回 ModelAndView 视图解析器将逻辑 View 解析为实际 View 将 Model 数据填充入实际 View 中，完成渲染 返回给客户端用户 重要组件 前端控制器 DispatcherServlet（重要）由框架提供，不需要开发 Spring MVC的入口函数。它负责接收请求，响应结果，相当于转发器，中央处理器。MVC模式中的C，即整个流程控制的中心，由它调用其它组件处理用户的请求，降低了组件之间的耦合。 处理器映射器 HandlerMapping根据请求的 URL 查找 Handler 处理器适配器 HandlerAdapter按照特定规则去执行Handler，是适配器模式的应用 处理器 Handler 需要开发 视图解析器 View Resolver视图解析，根据逻辑视图名解析成物理视图（即具体的页面地址），再生成View实际视图。 视图 View 需要开发。View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf 等）]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解AOP中通知顺序颠倒的bug]]></title>
    <url>%2F2019%2F04%2F29%2FSpring%E6%B3%A8%E8%A7%A3AOP%E4%B8%AD%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F%E9%A2%A0%E5%80%92%E7%9A%84bug%2F</url>
    <content type="text"><![CDATA[Spring框架有关注解AOP过程中的遇到的一个bug: Project Structure： 配置文件bean.xml： 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置Spring创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="wzc"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置Spring开启注解AOP的支持 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 业务层Service实现类： 123456789@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; public void saveAccount() &#123; System.out.println("执行了保存...");// int i = 1/0; &#125;&#125; 工具类Logger： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Component("logger")@Aspect//表示当前类是一个切面类public class Logger &#123; @Pointcut("execution(* wzc.service.impl.*.*(..))") private void pt1()&#123;&#125; /** * 前置通知 */ @Before("pt1()") public void beforePrintLog()&#123; System.out.println("前置通知Logger类中的beforePrintLog方法开始记录日志了..."); &#125; /** * 后置通知 */ @AfterReturning("pt1()") public void afterReturningPrintLog()&#123; System.out.println("后置通知Logger类中的afterReturningPrintLog方法开始记录日志了..."); &#125; /** * 异常通知 */ @AfterThrowing("pt1()") public void afterThrowingPrintLog()&#123; System.out.println("异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了..."); &#125; /** * 最终通知 */ @After("pt1()") public void afterPrintLog()&#123; System.out.println("最终通知Logger类中的afterPrintLog方法开始记录日志了..."); &#125; /** * 环绕通知 */ // @Around("pt1()") public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try &#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println("Logger类中的aroundPrintLog方法开始记录日志了...前置"); rtValue = pjp.proceed(args);//明确调用业务层方法(切入点方法) System.out.println("Logger类中的aroundPrintLog方法开始记录日志了...后置"); return rtValue; &#125; catch (Throwable t) &#123; System.out.println("Logger类中的aroundPrintLog方法开始记录日志了...异常"); throw new RuntimeException(t); &#125;finally &#123; System.out.println("Logger类中的aroundPrintLog方法开始记录日志了...最终"); &#125; &#125;&#125; 测试类AOPTest： 1234567891011public class AOPTest &#123; public static void main(String[] args) &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.获取对象 IAccountService as = (IAccountService) ac.getBean("accountService"); //3.执行方法 as.saveAccount(); &#125;&#125; 我们知道，正常的通知顺序应该是 配置前置通知@Before：在切入点方法执行之前执行 配置后置通知@AfterReturning：在切入点方法正常执行之后执行。它和异常通知永远只能执行一个 配置异常通知@AfterThrowing：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个 配置最终通知@After：无论切入点方法是否正常执行，它都会在其后面执行 配置环绕通知@Around：可以在代码中手动控制增强方法何时执行 BUG：使用注解配置通知时，产生后置通知与最终通知顺序颠倒的现象。把Service实现类中的数学异常注释放开，执行结果也相同：即发生异常通知与最终通知顺序颠倒的现象 而使用环绕通知的方式则通知顺序正常 结论:Spring基于注解的AOP中，这4个通知的执行调用顺序确实存在问题。因此，在我们的实际开发中，应该慎重考虑。 解决方案： 使用纯xml配置文件代替注解方式进行配置 在使用注解方式的前提下，建议使用没有顺序问题的环绕通知]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨服务器上传图片报错：403 Forbidden]]></title>
    <url>%2F2019%2F04%2F23%2F%E8%B7%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%8A%A5%E9%94%99%EF%BC%9A403%20Forbidden%2F</url>
    <content type="text"><![CDATA[问题: 跨服务器上传图片时, 单独部署了一个fileUploadServer的Tomcat结果图片一直无法上传成功, 报异常returned a response status of 403 Forbidden 原因: 存储图片的tomcat是默认只读的,需要在Tomcat所在目录-conf-web.xml中加入可写权限的配置 1234&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt; 问题解决, 图片上传成功]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>Issue</tag>
        <tag>服务器</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架学习_04]]></title>
    <url>%2F2019%2F04%2F18%2FMyBatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_04%2F</url>
    <content type="text"><![CDATA[MyBatis延迟加载策略延迟加载的定义 延迟加载： 就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载. 好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 坏处： 因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 实现需求 需求： 查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加载。 在03实现多表操作时，我们使用了resultMap来实现一对一，一对多，多对多关系的操作。主要是通过association、collection实现一对一及一对多映射。association、collection具备延迟加载功能。 项目结构12345678910111213141516171819202122232425262728─src ├─main │ ├─java │ │ └─wzc │ │ ├─dao │ │ │ IAccountDao.java │ │ │ IUserDao.java │ │ │ │ │ └─domain │ │ Account.java │ │ User.java │ │ │ └─resources │ │ jdbcConfig.properties │ │ log4j.properties │ │ SqlMapConfig.xml │ │ │ └─wzc │ └─dao │ IAccountDao.xml │ IUserDao.xml │ └─test └─java └─wzc └─test AccountTest.java UserTest.java 使用assocation实现延迟加载 账户持久层DAO接口的查询方法 12345/** * 查询所有账户,同时还要获取到当前账户的所属用户信息 * @return */List&lt;Account&gt; findAll(); 账户的持久层映射文件 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="wzc.dao.IAccountDao"&gt; &lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id="accountUserMap" type="account"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;!-- 配置延迟加载 select属性指定的内容:查询用户的唯一标识: column属性指定的内容:用户根据id查询时,所需要的参数的值 --&gt; &lt;association property="user" column="uid" javaType="user" select="wzc.dao.IUserDao.findById"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultMap="accountUserMap"&gt; SELECT * FROM account &lt;/select&gt;&lt;/mapper&gt; select： 填写我们要调用的 select 映射的 id column ： 填写我们要传递给 select 映射的参数 用户的持久层DAO接口的查询方法 123456/** * 根据id查询用户信息 * @param userId * @return */User findById(Integer userId); 用户的持久层映射文件 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="wzc.dao.IUserDao"&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id="findById" parameterType="int" resultType="user"&gt; SELECT * FROM user WHERE id = #&#123;uid&#125;; &lt;/select&gt;&lt;/mapper&gt; SqlMapConfig.xml中开启Mybatis的延迟加载策略 123456&lt;!-- 配置参数 --&gt;&lt;settings&gt; &lt;!-- 开启Mybatis支持延迟加载--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"&gt;&lt;/setting&gt;&lt;/settings&gt; 测试只查账户信息不查用户信息的方法 1234567891011121314151617181920212223242526272829303132333435public class AccountTest &#123; private InputStream in; private SqlSession sqlSession; private IAccountDao accountDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件,生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(); //4.获取dao的代理对象 accountDao = sqlSession.getMapper(IAccountDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy() throws Exception &#123; //要手动提交事务(autocommit默认为false) sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll()&#123; List&lt;Account&gt; accounts = accountDao.findAll(); &#125;&#125; 使用Collection实现延迟加载 同样我们也可以在一对多关系配置的结点中配置延迟加载策略。 结点中也有select属性，column属性。 需求： 完成加载用户对象时，查询该用户所拥有的账户信息。 在User实体类中加入List属性 12345678910//一对多关系映射:主表实体应该包含从表实体的集合引用private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts;&#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts;&#125; 用户持久层DAO接口方法 12345/** * 查询所有用户,同时获取到用户下所有账户的信息 * @return */List&lt;User&gt; findAll(); 账户持久层DAO接口方法 123456/** * 根据用户id查询账户信息 * @param uid * @return */List&lt;Account&gt; findAccountByUid(Integer uid); 用户持久层映射配置 12345678910111213141516&lt;!-- 定义User的ResultMap --&gt;&lt;resultMap id="userAccountMap" type="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property="accounts" ofType="account" select="wzc.dao.IAccountDao.findAccountByUid" column="id"&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 查询所有 --&gt;&lt;select id="findAll" resultMap="userAccountMap"&gt; SELECT * FROM user&lt;/select&gt; 标签： 主要用于加载关联的集合对象 select属性： 用于指定查询account列表的sql语句，所以填写的是该sql映射的id column属性： 用于指定select属性的sql语句的参数来源，上面的参数来自于user的id列，所以就写成id这一个字段名了 账户持久层映射配置 1234&lt;!-- 根据用户id查询账户列表 --&gt;&lt;select id="findAccountByUid" resultType="account"&gt; SELECT * FROM account WHERE uid = #&#123;uid&#125;&lt;/select&gt; 测试只加载用户信息的方法 1234@Testpublic void testFindAll()&#123; List&lt;User&gt; users = userDao.findAll();&#125; MyBatis缓存 像大多数的持久化框架一样，Mybatis也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。 Mybatis中缓存分为一级缓存，二级缓存。 项目结构12345678910111213141516171819202122232425─src ├─main │ ├─java │ │ └─wzc │ │ ├─dao │ │ │ IUserDao.java │ │ │ │ │ └─domain │ │ User.java │ │ │ └─resources │ │ jdbcConfig.properties │ │ log4j.properties │ │ SqlMapConfig.xml │ │ │ └─wzc │ └─dao │ IUserDao.xml │ └─test └─java └─wzc └─test SecondLevelCacheTest.java UserTest.java MyBatis一级缓存 证明一级缓存的存在 一级缓存是SqlSession级别的缓存，只要SqlSession没有flush或close，它就存在。 用户持久层DAO接口的方法 123456/** * 根据id查询用户信息 * @param userId * @return */User findById(Integer userId); 用户持久层映射文件 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="wzc.dao.IUserDao"&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id="findById" parameterType="int" resultType="user" useCache="true"&gt; SELECT * FROM user WHERE id = #&#123;uid&#125;; &lt;/select&gt;&lt;/mapper&gt; 测试方法 12345678910111213/** * 测试一级缓存 */@Testpublic void testFirstLevelCache()&#123; User user1 = userDao.findById(41); System.out.println("第一次查询的用户：" + user1); User user2 = userDao.findById(41); System.out.println("第二次查询的用户：" + user2); System.out.println(user1 == user2);&#125; 测试结果: true. 对数据库进行了一次查询 分析: 虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是Mybatis提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询id为41的记录时，并没有发出sql语句从数据库中查询数据，而是从一级缓存中查询。 一级缓存的分析 一级缓存是SqlSession范围的缓存，当调用SqlSession的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。 得到用户信息，将用户信息存储到一级缓存中。 如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。 测试一级缓存的清空 12345678910111213141516171819 @Test public void testFirstLevelCache()&#123; User user1 = userDao.findById(41); System.out.println(user1);// sqlSession.close(); //再次获取SqlSession对象// sqlSession = factory.openSession(); sqlSession.clearCache();//此方法也可以清空缓存 //再次获取dao代理对象 userDao = sqlSession.getMapper(IUserDao.class); User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2); &#125; 测试结果: false. 对数据库进行了两次查询 当执行sqlSession.close()后，再次获取sqlSession并查询id=41的User对象时，又重新执行了sql 语句，从数据库第二次进行了查询操作。 MyBatis二级缓存 二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 二级缓存结构 首先开启mybatis的二级缓存。 sqlSession1去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。 如果SqlSession3去执行相同 mapper映射下sql，执行commit提交，将会清空该 mapper映射下的二级缓存区域的数据。 sqlSession2去查询与sqlSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。 第一步：在SqlMapConfig.xml文件开启二级缓存 123&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 第二步：配置相关的Mapper映射文件 1234&lt;mapper namespace="wzc.dao.IUserDao"&gt; &lt;!-- 开启user支持二级缓存 --&gt; &lt;cache/&gt;&lt;/mapper&gt; 标签表示当前这个mapper映射将使用二级缓存，区分的标准就看mapper的namespace值。 第三步：配置statement上面的useCache属性 1234&lt;!-- 根据id查询用户 --&gt;&lt;select id="findById" parameterType="int" resultType="user" useCache="true"&gt; SELECT * FROM user WHERE id = #&#123;uid&#125;;&lt;/select&gt; 将映射文件中的select标签中设置useCache=”true”代表当前这个statement要使用二级缓存，如果不使用二级缓存可以设置为false。 注意：针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。 二级缓存测试 12345678910111213141516171819202122232425262728293031323334353637383940public class SecondLevelCacheTest &#123; private InputStream in; private SqlSessionFactory factory; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件,生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); &#125; @After//用于在测试方法执行之后执行 public void destroy() throws Exception &#123; in.close(); &#125; /** * 测试一级缓存 */ @Test public void testFirstLevelCache()&#123; SqlSession sqlSession1 = factory.openSession(); IUserDao dao1 = sqlSession1.getMapper(IUserDao.class); User user1 = dao1.findById(41); System.out.println(user1); sqlSession1.close();//一级缓存消失 SqlSession sqlSession2 = factory.openSession(); IUserDao dao2 = sqlSession2.getMapper(IUserDao.class); User user2 = dao2.findById(41); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2); &#125;&#125; 测试结果: false. 且只对数据库进行了一次查询 执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二次查询时，我们发现并没有对数据库发出sql语句，所以此时的数据就只能是来自于二级缓存。 二级缓存注意事项 当我们在使用二级缓存时，所缓存的类一定要实现java.io.Serializable接口，这种就可以使用序列化方式来保存对象。 MyBatis注解开发 这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。 MyBatis的常用注解说明 @Insert:实现新增 @Update:实现更新 @Delete:实现删除 @Select:实现查询 @Result:实现结果集封装 @Results:可以与 @Result一起使用，封装多个结果集 @ResultMap:实现引用 @Results定义的封装 @One:实现一对一结果集封装 @Many:实现一对多结果集封装 @SelectProvider: 实现动态SQL映射 @CacheNamespace:实现注解二级缓存的使用 项目结构1234567891011121314151617181920212223─src ├─main │ ├─java │ │ └─wzc │ │ ├─dao │ │ │ IUserDao.java │ │ │ │ │ └─domain │ │ User.java │ │ │ └─resources │ │ jdbcConfig.properties │ │ log4j.properties │ │ SqlMapConfig.xml │ │ │ └─wzc │ └─dao └─test └─java └─wzc └─test AnnotationCRUDTest.java MybatisAnnoTest.java ​ ​​ 使用MyBatis注解实现基本CRUD 实体类 1234567891011121314151617181920public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex;&#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125; &#125; 注意: 此处故意和数据库表的列名不一致。 使用注解方式开发持久层DAO接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("SELECT * FROM user") @Results(id="userMap", value=&#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday") &#125;) List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ @Insert("INSERT INTO user(username, address, sex, birthday) VALUES (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)") void saveUser(User user); /** * 更新用户 * @param user */ @Update("UPDATE user SET username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; WHERE id=#&#123;id&#125;") void updateUser(User user); /** * 删除用户 * @param userId */ @Delete("DELETE FROM user WHERE id=#&#123;id&#125;") void deleteUser(Integer userId); /** * 根据id查询用户 * @param userId * @return */ @Select("SELECT * FROM user WHERE id=#&#123;id&#125;") User findById(Integer userId); /** * 根据用户名模糊查询 * @param username * @return */// @Select("SELECT * FROM user WHERE username LIKE #&#123;username&#125;") @Select("SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%'") List&lt;User&gt; findUserByName(String username); /** * 查询总用户数量 * @return */ @Select("SELECT COUNT(*) FROM user") int findTotalUser();&#125; 通过注解方式，就不需要再去编写UserDao.xml 映射文件了。 SqlMapConfig 配置文件 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 引入外部配置文件 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;package name="wzc.domain"&gt;&lt;/package&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定带有注解的dao接口所在位置 --&gt; &lt;mappers&gt; &lt;package name="wzc.dao"&gt;&lt;/package&gt; &lt;/mappers&gt;&lt;/configuration&gt; 测试方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class AnnotationCRUDTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before public void init() throws Exception &#123; in = Resources.getResourceAsStream("SqlMapConfig.xml"); factory = new SqlSessionFactoryBuilder().build(in); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; session.commit(); session.close(); in.close(); &#125; @Test public void testSave()&#123; User user = new User(); user.setUsername("mybatis annotation"); user.setAddress("南京市鼓楼区"); userDao.saveUser(user); &#125; @Test public void testUpdate()&#123; User user = new User(); user.setId(56); user.setUsername("mybatis annotation update"); user.setAddress("南京市鼓楼区"); user.setSex("男"); user.setBirthday(new Date()); userDao.updateUser(user); &#125; @Test public void testDelete()&#123; userDao.deleteUser(54); &#125; @Test public void testFindOne()&#123; User user = userDao.findById(56); System.out.println(user); &#125; @Test public void testFindByName()&#123;// List&lt;User&gt; users = userDao.findUserByName("%mybatis%");//占位符 SELECT * FROM user WHERE username LIKE ? List&lt;User&gt; users = userDao.findUserByName("mybatis");//字符串拼接方式 SELECT * FROM user WHERE username LIKE '%mybatis%' for (User user : users) &#123; System.out.println(user); &#125; &#125; @Test public void testFindTotal()&#123; int total = userDao.findTotalUser(); System.out.println(total); &#125;&#125; 使用注解实现复杂关系映射开发 实现复杂关系映射之前我们可以在映射文件中通过配置来实现，在使用注解开发时我们需要借助@Results注解，@Result注解，@One注解，@Many注解。 项目结构123456789101112131415161718192021222324─src ├─main │ ├─java │ │ └─wzc │ │ ├─dao │ │ │ IAccountDao.java │ │ │ IUserDao.java │ │ │ │ │ └─domain │ │ Account.java │ │ User.java │ │ │ └─resources │ jdbcConfig.properties │ log4j.properties │ SqlMapConfig.xml │ └─test └─java └─wzc └─test AccountTest.java AnnotationCRUDTest.java SecondLevelCacheTest.java 复杂关系映射的注解说明 @Results注解 代替的是标签 该注解中可以使用单个@Result注解，也可以使用@Result集合 @Results（{@Result（），@Result（）}）或@Results（@Result（）） @Result注解 代替了 标签和标签 @Result 中 属性介绍： ​ id 是否是主键字段 ​ column 数据库的列名 ​ property需要装配的属性名 ​ one 需要使用的@One注解（@Result（one=@One）（））） ​ many 需要使用的@Many注解（@Result（many=@many）（））） @One注解（一对一） 代替了标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 @One注解属性介绍： ​ select 指定用来多表查询的sqlmapper ​ fetchType会覆盖全局的配置参数lazyLoadingEnabled。 使用格式： @Result(column=” “,property=””,one=@One(select=””)) @Many注解（多对一） 代替了标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意：聚集元素用来处理“一对多”的关系。需要指定映射的Java实体类的属性，属性的javaType（一般为ArrayList）但是注解中可以不定义； 使用格式： @Result(property=””,column=””,many=@Many(select=””)) 使用注解实现一对一复杂关系映射及延迟加载 User实体类及Account实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/*** 用户实体类*/public class User implements Serializable&#123; private Integer userId; private String userName; private String userAddress; private String userSex; private Date userBirthday; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; @Override public String toString() &#123; return "User&#123;" + "userId=" + userId + ", userName='" + userName + '\'' + ", userAddress='" + userAddress + '\'' + ", userSex='" + userSex + '\'' + ", userBirthday=" + userBirthday + '&#125;'; &#125;&#125;/*** 账户实体类*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //多对一(mybatis中称之为一对一)的映射:一个账户只能属于一个用户 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + '&#125;'; &#125;&#125; 账户的持久层DAO接口并使用注解配置 1234567891011121314151617181920public interface IAccountDao &#123; /** * 查询所有账户,并且获取每个账户所属的用户信息 * 注意:多对一@Result用@One注解,fetchType = FetchType.EAGER * 一对多@Result用@Many注解,fetchType = FetchType.LAZY * @return */ @Select("SELECT * FROM account") @Results(id = "accountMap", value = &#123; @Result(id = true,column = "id",property = "id"),//id=true表示该列为主键 @Result(column = "uid",property = "uid"), @Result(column = "money",property = "money"), @Result(property = "user", column = "uid", one = @One(select = "wzc.dao.IUserDao.findById",fetchType = FetchType.EAGER)), &#125;) List&lt;Account&gt; findAll();&#125; 用户的持久层DAO接口并使用注解配置 1234567891011121314151617181920212223242526public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("SELECT * FROM user") @Results(id = "userMap", value = &#123; @Result(id = true,column = "id",property = "userId"), @Result(column = "username",property = "userName"), @Result(column = "address",property = "userAddress"), @Result(column = "sex",property = "userSex"), @Result(column = "birthday",property = "userBirthday") &#125;) List&lt;User&gt; findAll(); /** * 根据id查询用户 * @param userId * @return */ @Select("SELECT * FROM user WHERE id=#&#123;id&#125;")// @ResultMap(value = &#123;"userMap"&#125;)//只有一个属性value可省略,数组中只有一个元素&#123;&#125;也可省略 @ResultMap("userMap") User findById(Integer userId);&#125; 测试一对一关联及延迟加载 123456789@Testpublic void testFindAll()&#123; List&lt;Account&gt; accounts = acountDao.findAll(); /*for (Account account : accounts) &#123; System.out.println("----------每个账户的信息-----------"); System.out.println(account); System.out.println(account.getUser()); &#125;*/&#125; 使用注解实现一对多复杂关系映射 需求： 查询用户信息时，也要查询他的账户列表。使用注解方式实现。 分析： 一个用户具有多个账户信息，所以形成了用户(User)与账户(Account)之间的一对多关系。 User实体类中加入List 12345678910//一对多关系映射:一个用户对应多个账户private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts;&#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts;&#125; 用户的持久层DAO接口并使用注解配置 12345678910111213141516171819public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("SELECT * FROM user") @Results(id = "userMap", value = &#123; @Result(id = true,column = "id",property = "userId"), @Result(column = "username",property = "userName"), @Result(column = "address",property = "userAddress"), @Result(column = "sex",property = "userSex"), @Result(column = "birthday",property = "userBirthday"), @Result(property = "accounts",column = "id", many = @Many(select = "wzc.dao.IAccountDao.findAccountByUid", fetchType = FetchType.LAZY)) &#125;) List&lt;User&gt; findAll();&#125; @Many: 相当于的配置 select属性：代表将要执行的sql语句 fetchType属性：代表加载方式，一般如果要延迟加载都设置为LAZY的值 账户的持久层DAO接口并使用注解配置 123456789public interface IAccountDao &#123; /** * 根据用户id查询账户信息 * @param userId * @return */ @Select("SELECT * FROM account WHERE uid = #&#123;userId&#125;") List&lt;Account&gt; findAccountByUid(Integer userId);&#125; 测试方法 123456789101112131415161718192021222324252627282930313233public class AnnotationCRUDTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before public void init() throws Exception &#123; in = Resources.getResourceAsStream("SqlMapConfig.xml"); factory = new SqlSessionFactoryBuilder().build(in); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy() throws Exception &#123; session.commit(); session.close(); in.close(); &#125; @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println("------每个用户的信息--------"); System.out.println(user); System.out.println(user.getAccounts()); &#125; &#125;&#125; MyBatis基于注解的二级缓存 在SqlMapConfig中开启二级缓存支持 1234&lt;!-- 配置开启二级缓存 --&gt;&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 在持久层DAO接口中使用注解配置二级缓存 1234@CacheNamespace(blocking = true)//mybatis基于注解方式实现配置二级缓存public interface IUserDao &#123;...&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架学习_03]]></title>
    <url>%2F2019%2F04%2F16%2FMyBatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_03%2F</url>
    <content type="text"><![CDATA[MyBatis连接池与事务深入MyBatis的连接池技术​ Mybatis中也有连接池技术，它采用的是自己的连接池技术。在Mybatis的SqlMapConfig.xml配置文件中，通过来实现Mybatis中连接池的配置。 MyBatis连接池分类 Mybatis将它自己的数据源分为三类： UNPOOLED 不使用连接池的数据源 POOLED 使用连接池的数据源 JNDI 使用JNDI实现的数据源 在这三种数据源中，我们一般采用的是POOLED数据源. MyBatis中DataSource的配置 DataSource的配置在SqlMapConfig.xml文件中, 具体如下: 1234567&lt;!-- 配置连接池 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/dataSource&gt; MyBatis中DataSource的存取 ​ MyBatis是通过工厂模式来创建数据源DataSource对象的，MyBatis定义了抽象的工厂接口: org.apache.ibatis.datasource.DataSourceFactory, 通过其getDataSource()方法返回数据源DataSource。 MyBatis的事务控制 JDBC中的事务 ​ JDBC中我们可以通过手动方式将事务的提交改为手动方式，通过setAutoCommit()方法调整。 Mybatis中事务提交方式 ​ Mybatis中事务的提交方式，本质上就是调用JDBC的setAutoCommit()来实现事务控制。 123456789101112131415161718192021222324252627282930313233343536/** * 测试保存操作 */@Testpublic void testSave() &#123; User user = new User(); user.setUsername("autocommit"); user.setAddress("南京市玄武区"); user.setSex("男"); user.setBirthday(new Date()); System.out.println("保存操作之前:" + user); //执行保存方法 userDao.saveUser(user); System.out.println("保存操作之后:" + user);&#125;@Before//用于在测试方法执行之前执行public void init() throws Exception &#123; //1.读取配置文件,生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(); //4.获取dao的代理对象 userDao = sqlSession.getMapper(IUserDao.class);&#125; @After//用于在测试方法执行之后执行public void destroy() throws Exception &#123; //要手动提交事务(autocommit默认为false) sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close();&#125; 注: 在CUD操作过程中，我们都要手动进行事务的提交，原因是setAutoCommit()方法，在执行时它的值被设置为false了，所以我们在CUD操作中，必须通过sqlSession.commit()方法来执行提交操作。 Mybatis自动提交事务的设置 在工厂对象的openSession方法中传入一个boolean值, 实现事务提交 123456789101112131415161718@Before//用于在测试方法执行之前执行public void init() throws Exception &#123; //1.读取配置文件,生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(true); //4.获取dao的代理对象 userDao = sqlSession.getMapper(IUserDao.class);&#125; @After//用于在测试方法执行之后执行public void destroy() throws Exception &#123; //5.释放资源 sqlSession.close(); in.close();&#125; MyBatis动态SQL语句动态SQL之标签 持久层Dao接口 123456/** * 根据传入的参数条件查询 * @param user 查询的条件:有可能有用户名,有可能有性别,也有可能有地址,还有可能都有或都没有 * @return */List&lt;User&gt; findUserByCondition(User user); 持久层Dao映射配置 123456789&lt;select id="findUserByCondition" resultType="wzc.domain.User" parameterType="user"&gt; SELECT * FROM user WHERE 1=1 &lt;if test="username != null"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test="sex != null"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt;&lt;/select&gt; 注意：标签的test属性中写的是对象的属性名，如果是包装类的对象要使用OGNL表达式的写法。 另外要注意where 1=1 的作用 测试 1234567891011@Testpublic void testFindByCondition() &#123; User u = new User(); u.setUsername("老王"); u.setSex("女"); //执行条件查询方法 List&lt;User&gt; users = userDao.findUserByCondition(u); for (User user : users) &#123; System.out.println(user); &#125;&#125; 动态SQL之标签​ 为了简化上面where 1=1的条件拼装，我们可以采用标签来简化开发。 持久层Dao映射配置 1234567891011&lt;select id="findUserByCondition" resultMap="userMap" parameterType="user"&gt; SELECT * FROM user &lt;where&gt; &lt;if test="username != null"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test="sex != null"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 动态SQL之标签 需求传入多个id查询用户信息，用下边两个sql实现： SELECT * FROM USERS WHERE username LIKE ‘%张%’ AND (id =10 OR id =89 OR id=16) SELECT * FROM USERS WHERE username LIKE ‘%张%’ AND id IN (10,89,16) 在QueryVo中加入一个List集合ids用于封装参数 12345678910111213141516171819202122public class QueryVo implements Serializable&#123; private User user; private List&lt;Integer&gt; ids; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public List&lt;Integer&gt; getIds() &#123; return ids; &#125; public void setIds(List&lt;Integer&gt; ids) &#123; this.ids = ids; &#125;&#125; 持久层Dao接口 123456/** * 根据QueryVo中提供的id集合,查询用户信息 * @param vo * @return */List&lt;User&gt; findUserInIds(QueryVo vo); 持久层Dao映射配置 1234567891011&lt;!-- 根据queryvo中的Id集合实现查询用户列表 --&gt;&lt;select id="findUserInIds" resultType="user" parameterType="queryvo"&gt; &lt;include refid="defaultUser"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="ids != null and ids.size()&gt;0"&gt; &lt;foreach collection="ids" open="AND id IN (" close=")" item="id" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; SQL语句： select 字段 from user where id in ? 标签用于遍历集合，它的属性： collection:代表要遍历的集合元素，注意编写时不要写#{} open:代表语句的开始部分 close:代表结束部分 item:代表遍历集合的每个元素，生成的变量名 sperator:代表分隔符 编写测试方法 123456789101112131415@Testpublic void testFindInIds() &#123; QueryVo vo = new QueryVo(); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(41); list.add(42); list.add(46); vo.setIds(list); //5.执行查询所有方法 List&lt;User&gt; users = userDao.findUserInIds(vo); for (User user : users) &#123; System.out.println(user); &#125;&#125; MyBatis中简化编写的SQL片段 定义代码片段 1234&lt;!-- 了解:抽取重复的sql语句 --&gt;&lt;sql id="defaultUser"&gt; SELECT * FROM user&lt;/sql&gt; 引用代码片段 1234567891011&lt;select id="findUserByCondition" resultMap="userMap" parameterType="user"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="username != null"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test="sex != null"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; MyBatis多表查询之一对多一对一查询(多对一)方式一1.定义账户信息实体类 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.Serializable;public class Account implements Serializable&#123; private Integer id; private Integer uid; private double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + '&#125;'; &#125;&#125; 2.编写SQL 实现查询账户信息时，也要查询账户所对应的用户信息。 123456789SELECT a.*, u.username, u.address FROM account a, user uWHERE a.uid = u.id 3.定义AccountUser类 ​ 为了能够封装上面SQL语句的查询结果，定义 AccountCustomer类中要包含账户信息同时还要包含用户信息，所以我们要在定义AccountUser类时可以继承Account类。 1234567891011121314151617181920212223242526272829public class AccountUser extends Account &#123; private String username; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return super.toString() + " AccountUser&#123;" + "username='" + username + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 4.定义账户持久层Dao接口 123456789101112import wzc.domain.Account;import wzc.domain.AccountUser;import java.util.List;public interface IAccountDao &#123; /** * 查询所有账户,同时还要获取到当前账户的所属用户信息 * @return */ List&lt;AccountUser&gt; findAll();&#125; 5.定义AccountDao.xml文件中的查询配置信息 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="wzc.dao.IAccountDao"&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultMap="accountUserMap"&gt; SELECT a.*,u.username, u.address FROM account a, user u WHERE u.id = a.uid &lt;/select&gt;&lt;/mapper&gt; 6.创建AccountTest测试类 1234567891011121314151617181920212223242526272829303132333435363738public class AccountTest &#123; private InputStream in; private SqlSession sqlSession; private IAccountDao accountDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件,生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(); //4.获取dao的代理对象 accountDao = sqlSession.getMapper(IAccountDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy() throws Exception &#123; //要手动提交事务(autocommit默认为false) sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll()&#123; List&lt;AccountUser&gt; accountusers = accountDao.findAll(); for (AccountUser au : accountusers) &#123; System.out.println(au); &#125; &#125;&#125; 7.小节 ​ 方法一定义了专门的pojo类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。 方式二使用resultMap，定义专门的resultMap用于映射一对一查询结果。 通过面向对象的(has a)关系可以得知，我们可以在Account类中加入一个User类的对象来代表这个账户是哪个用户的。 修改Account类 在Account类中加入User类的对象作为Account类的一个属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.Serializable;public class Account implements Serializable&#123; private Integer id; private Integer uid; private double money; //从表实体应该包含一个主表实体的对象引用 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + '&#125;'; &#125;&#125; 修改AccountDao接口中的方法 12345/** * 查询所有账户,同时还要获取到当前账户的所属用户信息 * @return */List&lt;Account&gt; findAll(); 注意：方式二将返回值改 为了Account类型。 因为Account类中包含了一个User类的对象，它可以封装账户所对应的用户信息。 重新定义AccountDao.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="wzc.dao.IAccountDao"&gt; &lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id="accountUserMap" type="account"&gt; &lt;id property="id" column="aid"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射:配置封装user的内容 --&gt; &lt;association property="user" column="uid" javaType="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultMap="accountUserMap"&gt; SELECT u.*,a.id AS aid, a.uid,a.money FROM account a, user u WHERE u.id = a.uid &lt;/select&gt;&lt;/mapper&gt; 在AccountTest类中加入测试方法 123456789@Testpublic void testFindAll()&#123; List&lt;Account&gt; accounts = accountDao.findAll(); for (Account account : accounts) &#123; System.out.println("----------每个account的信息-------------"); System.out.println(account); System.out.println(account.getUser()); &#125;&#125; 一对多查询需求： 查询所有用户信息及用户关联的账户信息。 分析： 用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息查询出来，此时左外连接查询比较合适。 编写SQL 1234567891011SELECT u.*, a.id aid, a.uid, a.money FROM user u LEFT JOIN account aON u.id = a.uid User类加入List 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.Serializable;import java.util.Date;import java.util.List;public class User implements Serializable&#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //一对多关系映射:主表实体应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", address='" + address + '\'' + ", sex='" + sex + '\'' + ", birthday=" + birthday + '&#125;'; &#125;&#125; 用户持久层Dao接口中加入查询方法 12345/** * 查询所有用户,同时获取到用户下所有账户的信息 * @return */List&lt;User&gt; findAll(); 用户持久层UserDao映射文件配置 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="wzc.dao.IUserDao"&gt; &lt;!-- 定义User的ResultMap --&gt; &lt;resultMap id="userAccountMap" type="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property="accounts" ofType="account"&gt; &lt;id column="aid" property="id"&gt;&lt;/id&gt; &lt;result column="uid" property="uid"&gt;&lt;/result&gt; &lt;result column="money" property="money"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultMap="userAccountMap"&gt; select u.*,a.id as aid ,a.uid,a.money from user u left outer join account a on u.id =a.uid &lt;/select&gt;&lt;/mapper&gt; collection : 部分定义了用户关联的账户信息。表示关联查询结果集 property=”accounts”： 关联查询的结果集存储在User对象的上哪个属性。 ofType=”account”： 指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定类名。 测试方法 123456789@Testpublic void testFindAll()&#123; List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println("-----------------每个用户的信息------------------"); System.out.println(user); System.out.println(user.getAccounts()); &#125;&#125; MyBatis多表查询之多对多实现Role到User的多对多通过前面的学习，我们使用MyBatis 实现一对多关系的维护。多对多关系其实我们看成是双向的一对多关系。 用户与角色的关系模型 业务要求及SQL 需求： 实现查询所有对象并且加载它所分配的用户信息。 分析： 查询角色我们需要用到Role表，但角色分配的用户的信息我们并不能直接找到用户信息，而是要通过中间表(USER_ROLE表)才能关联到用户信息。 下面是实现的SQL语句： 123456789101112131415SELECT r.*, u.id uid, u.username username, u.birthday birthday, u.sex sex, u.address address FROM ROLE r INNER JOIN USER_ROLE ur ON ( r.id = ur.rid) INNER JOIN USER u ON (ur.uid = u.id); 编写Role实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.Serializable;import java.util.List;public class Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; //多对多的关系映射:一个角色可以赋予多个用户 private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; public Integer getRoleId() &#123; return roleId; &#125; public void setRoleId(Integer roleId) &#123; this.roleId = roleId; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getRoleDesc() &#123; return roleDesc; &#125; public void setRoleDesc(String roleDesc) &#123; this.roleDesc = roleDesc; &#125; @Override public String toString() &#123; return "Role&#123;" + "roleId=" + roleId + ", roleName='" + roleName + '\'' + ", roleDesc='" + roleDesc + '\'' + '&#125;'; &#125;&#125; 编写Role持久层接口 12345678910import wzc.domain.Role;import java.util.List;public interface IRoleDao &#123; /** * 查询所有角色 * @return */ List&lt;Role&gt; findAll();&#125; 编写映射文件 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="wzc.dao.IRoleDao"&gt; &lt;!-- 定义role表的ResultMap --&gt; &lt;resultMap id="roleMap" type="role"&gt;&lt;!-- 由于在SqlMapConfig中定义过别名,type可以简写 --&gt; &lt;id property="roleId" column="rid"&gt;&lt;/id&gt;&lt;!-- property写javabean中的变量名,column写DB中的列名,由于sql语句中id被命名为rid,所以这里column属性必须写rid --&gt; &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt;&lt;!-- 此处注意:windows系统中mysql数据库不区分大小写,Linux系统中区分大小写 --&gt; &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt; &lt;collection property="users" ofType="user"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultMap="roleMap"&gt; SELECT u.*,r.id AS rid,r.role_name,r.role_desc FROM role r LEFT OUTER JOIN user_role ur ON r.id=ur.rid LEFT OUTER JOIN user u ON u.id=ur.uid &lt;/select&gt;&lt;/mapper&gt; 注意: windows系统中mysql数据库不区分大小写,Linux系统中区分大小写 测试类 12345678910111213141516171819202122232425262728293031323334353637383940public class RoleTest &#123; private InputStream in; private SqlSession sqlSession; private IRoleDao roleDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件,生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(true); //4.获取dao的代理对象 roleDao = sqlSession.getMapper(IRoleDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy() throws Exception &#123; //要手动提交事务(autocommit默认为false,已设为true) //sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll()&#123; List&lt;Role&gt; roles = roleDao.findAll(); for (Role role : roles)&#123; System.out.println("----------每个角色的信息-------------"); System.out.println(role); System.out.println(role.getUsers()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PLSQL登录报错：ORA-12514]]></title>
    <url>%2F2019%2F04%2F03%2FPLSQL%E7%99%BB%E5%BD%95%E6%8A%A5%E9%94%99%EF%BC%9AORA-12514%2F</url>
    <content type="text"><![CDATA[问题：在用PLSQL连接虚拟机上的Oracle数据库时, 出现如下图错误 解决方法： 打开虚拟机，win+R打开命令行 输入sqlplus /nolog登录Oracle 输入conn sys / as sysdba;以dba身份连接，然后输入登录密码(你自己设置的) 输入shutdown immediate;关闭数据库 输入startup;开启数据库 等待出现数据库装载完毕。数据库已经打开 重新登录PLSQL，正常连接虚拟机Oracle，问题解决。]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>Issue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《高性能MySQL》学习笔记]]></title>
    <url>%2F2019%2F03%2F20%2F%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[高性能MySQL一 MySQL架构与历史 MySQL的逻辑架构： 最上层：服务器层服务。非MySQL独有，基于网络客户端\服务器工具都有类似架构。如连接处理、授权认证、安全等。 第二层：MySQL核心服务功能层。包括查询解析、分析、优化、缓存以及所有内置函数（如日期、时间、数学和加密函数）。所有跨存储引擎功能在这层实现：存储过程、触发器、视图等。 第三层：存储引擎。负责数据存储和提取。 锁 处理并发读写： 共享锁(shared lock)：读锁(read lock) 读锁是共享的，相互不阻塞的，多个用户同一时刻可以读取同一个资源，且互不干扰。 排他锁(exclusive lock)：写锁(write lock) 写锁则是排他的，一个写锁会阻塞其他的写锁和读锁，确保给定时间内，只有一个用户能执行写入，防止其他用户读取正在写入的同一资源。 锁粒度：锁的各种操作都会增加系统开销。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。 锁策略： 表锁(table lock)：开销最小。会锁定整张表 行级锁(row lock)：开销最大。在InnoDB和XtraDB存储引擎层实现了行级锁。 事务： 事务的四大特性（ACID） 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性： 执行事务前后，数据库从一个一致性状态转换到另一个一致性状态。 隔离性： 并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响。 隔离级别 READ_UNCOMMITTED（未提交读）: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 READ_COMMITTED（提交读）: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 REPEATABLE_READ（可重复读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE（串行）: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 注意：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别. MySQL的存储引擎 InnoDB：MySQL的默认事务型引擎，是最重要、使用最广泛的存储引擎。 是一个事务型数据库引擎。处理大量短期事务很少回滚。 性能优越，自动崩溃回复特性。 Oracle在MySQL5.5版本时将InnoDB作为默认存储引擎 InnoDB采用MVCC支持高并发，实现了四个标准隔离级别，其默认隔离级别是REPEATABLE READ(可重复读)，并且通过锁间隙(next-key locking)策略防止幻读。 InnoDB表时基于聚簇索引建立的，对主键查询有很高的性能。它的二级索引(secondary index)中必须包含主键列。 InnoDB从磁盘读取时采用可预测性预读，自动在内存中创建hash索引加速读操作的自适应哈希索引(adaptive hash index)，以及能加速插入操作的插入缓冲区(insert buffer)。 MyISAM存储引擎：MySQL5.1及之前版本MySQL的默认存储引擎。 全文索引、压缩、空间函数(GIS) 不支持事务和行级锁 崩溃后无法安全恢复 对于只读或较小数据，可以使用MyISAM 转换存储引擎 ALTER TABLE ALTER TABLE mytable ENGINE = InnoDB; MySQL时间线(Timeline) 服务器层面不同并发下的每秒事务数测试结果： 折线图： 二 MySQL基准测试 基准测试(benchmark) 定义：针对系统设计的一种压力测试。 目的：掌握系统的行为。 测试指标 吞吐量(throughput)：单位时间内的事务处理数。测试单位：TPS(Transaction Per Second)：每秒事务处理数TPM(Transaction Per Minute)：每分钟事务处理数 响应时间或延迟(latency)：测试任务所需的整体时间。测试单位：平均、最小、最大响应时间百分比响应时间(percentile response time) 并发性：同时工作中的线程数或连接数。当并发性增加时，测量吞吐量是否下降，响应时间是否延长目的：为了测试应用在不同并发下的性能。 可扩展性：给系统增加一倍工作，理想情况获得两倍效果(吞吐量增加一倍)。实际上无法做到线性扩展。目的：提供其他测试无法提供的信息，帮助发现应用的瓶颈。 测试方法 设计规划基准测试 确定基准测试时间： 达到系统稳定状态 获取系统性能和状态 运行基准测试并分析结果 通常要运行多次取均值。 编写shell脚本收集分析数据 将性能指标按照时间顺序绘图，可以更快发现问题，如下图性能尖刺在压力大的系统较常见，由于使用InnoDB，脏块刷新算法性能差，一开始的低谷是系统缓存产生的，后面其他下跌则是系统刷新脏块到磁盘导致 测试工具 集成式测试工具：ab, http_load, JMeter 单组件式测试工具：mysqlslap, MySQL Benchmark Suite(sql-bench), Super Smack, sysbench 尽量早和多地使用绘图的方式，来发现基准测试和系统中的问题和错误。你的眼睛是比任何脚本和自动化工具都更有效的发现问题的工具。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于阿里云轻量级服务器封25和465端口无法发送邮件问题的解决方案]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%85%B3%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%8125%E5%92%8C465%E7%AB%AF%E5%8F%A3%E6%97%A0%E6%B3%95%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[最近进行SSM项目实践，将项目部署到阿里云轻量级服务器上时，发现在自己电脑上测试可用的发送邮件工具类无法使用。上网查阅资料, 得知是阿里云封掉了发送邮件的25和465端口。 于是将25端口发送邮件的工具类稍加改造，整理代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Properties;import javax.mail.internet.MimeMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;import org.springframework.mail.javamail.MimeMessageHelper;public class MailUtils587 &#123; private static JavaMailSenderImpl javaMailSender; private static String userName = "xxxxxxxxx@qq.com"; static &#123; javaMailSender = new JavaMailSenderImpl(); javaMailSender.setHost("smtp.qq.com");// 连接服务器 javaMailSender.setUsername(userName);// 账号 javaMailSender.setPassword("xxxxxxxxxxxxx");// 密码 javaMailSender.setDefaultEncoding("UTF-8"); Properties properties = new Properties(); // 设置通过ssl协议使用587端口发送、使用默认端口（25）时下面三行不需要 properties.setProperty("mail.smtp.auth", "true");// 开启认证 properties.setProperty("mail.smtp.socketFactory.port", "587");// 设置ssl端口 properties.setProperty("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory"); javaMailSender.setJavaMailProperties(properties); &#125; public static void sendEmail(final String title, final String content, final String toMail) &#123; new Thread(new Runnable() &#123;// 开启线程异步发送 防止发送请求时间过长 @Override public void run() &#123; try &#123; if (!toMail.equals("")) &#123; String[] toAddress = toMail.split(","); MimeMessage message = javaMailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8"); helper.setFrom(userName); helper.setTo(toAddress); helper.setSubject(title); helper.setText(content, true); // 内容 javaMailSender.send(message); // 发送邮件 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; //测试发送 public static void main(String[] args) &#123; sendEmail("title", "content", "xxxxxxxxxx@qq.com"); &#125;&#125; 完美解决！亲测某讯邮箱可用~ 注意: 密码不是登陆密码, 而是用于登录第三方客户端邮箱的授权码, 该授权码可以在QQ邮箱-设置-账户中通过二维码获取; 需要先在pom中导入spring-context-support 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>Issue</tag>
        <tag>SSM</tag>
        <tag>Utils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架学习_02]]></title>
    <url>%2F2019%2F03%2F14%2FMyBatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_02%2F</url>
    <content type="text"><![CDATA[基于代理Dao实现CRUD操作根据ID查询 持久层接口中添加findById方法 123456/** * 根据id查询用户信息 * @param userId * @return */User findById(Integer userId); 在用户的映射配置文件中配置 1234&lt;!-- 根据id查询用户 --&gt;&lt;select id="findById" parameterType="int" resultType="wzc.domain.User"&gt; SELECT * FROM user WHERE id = #&#123;uid&#125;;&lt;/select&gt; 细节: resultType属性： 用于指定结果集的类型。 parameterType属性：用于指定传入参数的类型。 sql语句中使用#{}字符： 它代表占位符，相当于原来jdbc部分的 ?，都是用于执行语句时替换实际的数据。 具体的数据是由#{}里面的内容决定的。 #{}中内容的写法： 由于数据类型是基本类型，所以此处可以随意写。 在测试类添加测试 123456789101112131415161718192021222324252627282930313233public class MybatisTest &#123; private InputStream in; private SqlSession sqlSession; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init() throws Exception &#123; //1.读取配置文件,生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(); //4.获取dao的代理对象 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy() throws Exception &#123; //要手动提交事务(autocommit默认为false) sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; @Test public void testFindOne()&#123; User user = userDao.findById(41); System.out.println(user); &#125;&#125; 保存操作 在持久层接口中添加保存方法 12345/** * 保存用户 * @param user */void saveUser(User user); 在用户的映射配置文件中配置 1234&lt;!-- 保存用户 --&gt;&lt;insert id="saveUser" parameterType="wzc.domain.User"&gt; INSERT INTO user(username,address,sex,birthday) VALUES(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;);&lt;/insert&gt; 细节： parameterType属性： 代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。 sql语句中使用#{}字符： 它代表占位符，相当于原来jdbc部分所学的?，都是用于执行语句时替换实际的数据。 具体的数据是由#{}里面的内容决定的。 #{}中内容的写法： 由于我们保存方法的参数是 一个User对象，此处要写User对象中的属性名称。 它用的是ognl表达式。 ognl表达式： 它是apache提供的一种表达式语言，全称是： Object Graphic Navigation Language 对象图导航语言 它是按照一定的语法格式来获取数据的。 语法格式就是使用 #{对象.属性}的方式. #{user.username}会先去找user对象，然后在user对象中找到username属性，并调用getUsername()方法把值取出来。但是我们在parameterType属性上指定了实体类名称，所以可以省略user.而直接写username。 添加测试类中的测试方法 1234567891011121314151617/** * 测试保存操作 */@Testpublic void testSave() &#123; User user = new User(); user.setUsername("mybatis last insertid"); user.setAddress("南京市玄武区"); user.setSex("男"); user.setBirthday(new Date()); System.out.println("保存操作之前:" + user); //执行保存方法 userDao.saveUser(user); System.out.println("保存操作之后:" + user);&#125; 注意: destroy()方法中的sqlSession.commit();实现了事务的提交. 问题扩展：新增用户id的返回值 ​ 新增用户后，同时还要返回当前新增用户的id值，因为id是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长auto_increment的值返回。 12345678&lt;!-- 保存用户 --&gt;&lt;insert id="saveUser" parameterType="wzc.domain.User"&gt; &lt;!-- 配置插入操作后,获取插入数据的id --&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt; SELECT last_insert_id(); &lt;/selectKey&gt; INSERT INTO user(username,address,sex,birthday) VALUES(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;);&lt;/insert&gt; 更新操作 在持久层接口中添加更新方法 12345/** * 更新用户 * @param user */void updateUser(User user); 在用户映射配置文件中配置 1234&lt;!-- 更新用户 --&gt;&lt;update id="updateUser" parameterType="wzc.domain.User"&gt; UPDATE user SET username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125; WHERE id = #&#123;id&#125;;&lt;/update&gt; 加入更新测试方法 123456789101112@Testpublic void testUpdate() &#123; User user = new User(); user.setId(50); user.setUsername("mybatis Update user"); user.setAddress("南京市玄武区"); user.setSex("女"); user.setBirthday(new Date()); //5.执行更新方法 userDao.updateUser(user);&#125; 删除操作 在持久层就扣中添加删除方法 12345/** * 根据Id删除用户 * @param userId */void deleteUser(Integer userId); 在用户映射配置文件中配置 1234&lt;!-- 删除用户 --&gt;&lt;delete id="deleteUser" parameterType="int"&gt; DELETE FROM user WHERE id = #&#123;uid&#125;;&lt;/delete&gt; 注: 只有一个占位符, 且parameterType为基本类型时, 大括号{}内可以写任何字符 加入删除测试方法 12345@Testpublic void testDelete() &#123; //执行删除方法 userDao.deleteUser(51);&#125; 模糊查询 在持久层接口中添加模糊查询方法 123456/** * 根据名称模糊查询用户信息 * @param username * @return */List&lt;User&gt; findByName(String username); 在用户的映射配置文件中配置 12345&lt;!-- 根据名称模糊查询 --&gt;&lt;select id="findByName" parameterType="String" resultType="wzc.domain.User"&gt; SELECT * FROM user WHERE username LIKE #&#123;name&#125;; &lt;!-- SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%'; --&gt;&lt;/select&gt; 加入模糊查询的测试方法 1234567891011 @Test public void testFindByName() &#123; //执行查询一个方法 List&lt;User&gt; users = userDao.findByName("%王%");// List&lt;User&gt; users = userDao.findByName("王"); for (User user : users) &#123; System.out.println(user); &#125; &#125; 模糊查询的另一种配置方式 ​ 修改SQL语句配置, 且测试类中不再需要写% 1SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%'; #{}与${}的区别 #{}表示一个占位符号 通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ${}表示拼接sql串 通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 使用聚合函数查询 在持久层接口中添加查询方法 12345/** * 查询总用户数 * @return */int findTotal(); 在用户的映射配置文件中配置 1234&lt;!-- 获取用户的总记录条数 --&gt;&lt;select id="findTotal" resultType="int"&gt; SELECT COUNT(id) FROM user;&lt;/select&gt; 加入聚合查询的测试方法 123456@Testpublic void testFindTotal() &#123; //执行查询总记录方法 int count = userDao.findTotal(); System.out.println(count);&#125; MyBatis与JDBC编程比较总结 JDBC: 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 MyBatis: 在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。 JDBC:Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。 MyBatis:将Sql语句配置在XXXXmapper.xml文件中与java代码分离。 JDBC:向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数对应。 MyBatis:自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。 JDBC:对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。 MyBatis:自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。 MyBatis的参数深入parameterType配置参数 SQL语句传参，使用标签的parameterType属性来设定。该属性的取值可以是基本类型，引用类型（例如:String类型），还可以是实体类类型（POJO类）。同时也可以使用实体类的包装类. 下面介绍如何使用实体类的包装类作为参数传递. 基本类型和String我们可以直接写类型名称，也可以使用包名.类名的方式，例如：java.lang.String。 实体类类型，目前只能使用全限定类名。mybaits在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名，而我们的是实体类并没有注册别名，所以必须写全限定类名。(在注册实体类别名之前) 传递pojo包装对象 编写QueryVo 123456789101112public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 持久层接口的映射文件 1234&lt;!-- 根据queryVo的条件查询用户 --&gt;&lt;select id="findUserByVo" parameterType="wzc.domain.QueryVo" resultType="wzc.domain.User"&gt; SELECT * FROM user WHERE username LIKE #&#123;user.username&#125;;&lt;/select&gt; 测试包装类作为参数 123456789101112131415@Testpublic void testFindByVo() &#123; QueryVo vo = new QueryVo(); User user = new User(); user.setUsername("%王%"); vo.setUser(user); //执行查询方法,参数是一个QueryVo对象 List&lt;User&gt; users = userDao.findUserByVo(vo); for (User u : users) &#123; System.out.println(u); &#125;&#125; MyBatis的输出结果封装resultType配置结果类型​ resultType属性可以指定结果集的类型，它支持基本类型和实体类类型。需要注意的是，它和parameterType一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。 基本类型示例(如聚合函数查询, 返回int类型) 实体类类型示例(如查询所有操作, 返回List类型) 特殊情况示例(实体类属性名称和数据库表的列名不一致) 修改实体类 1234567891011121314151617public class User implements Serializable &#123; private Integer userId; //数据库列名idprivate String userName; //数据库列名usernameprivate Date userBirthday; //数据库列名birthdayprivate String userSex; //数据库列名sexprivate String userAddress; //数据库列名address public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123;this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125; &#125; Dao接口中添加查询所有方法 12345/** * 查询所有用户 * @return */List&lt;User&gt; findAll(); 映射配置 1234&lt;!-- 查询所有 --&gt;&lt;select id="findAll" resultType="wzc.domain.User"&gt; SELECT * FROM user;&lt;/select&gt; 测试查询结果 12345678@Testpublic void testFindAll() &#123; //5.执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125;&#125; 测试结果: 除了userName有值, 其他都是null 原因: mysql在windows系统中不区分大小写.所以实体类属性userName与数据库列名username是一致的. resultMap结果类型​ resultMap标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在select标签中使用resultMap属性指定引用即可。同时resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。 使用resultMap解决上一节实体类无法封装的问题 定义resultMap 1234567891011&lt;!-- 建立User实体和数据库表的对应关系 type属性：指定实体类的全限定类名 id属性：给定一个唯一标识，是给查询select标签引用用的。 --&gt;&lt;resultMap type="wzc.domain.User" id="userMap"&gt; &lt;id column="id" property="userId"/&gt; &lt;result column="username" property="userName"/&gt; &lt;result column="sex" property="userSex"/&gt; &lt;result column="address" property="userAddress"/&gt; &lt;result column="birthday" property="userBirthday"/&gt; &lt;/resultMap&gt; id标签：用于指定主键字段 result标签：用于指定非主键字段 column属性：用于指定数据库列名 property属性：用于指定实体类属性名称 映射配置 1234&lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultMap="userMap"&gt; select * from user &lt;/select&gt; 测试查询结果 12345678@Testpublic void testFindAll() &#123; //执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125;&#125; 测试结果: 所有属性值封装成功. SqlMapConfig.xml配置文件配置内容 SqlMapConfig.xml配置的内容和顺序 123456789101112131415161718192021222324252627282930313233-properties（属性） ​ --property -settings（全局配置参数） ​ --setting -typeAliases（类型别名）​ --typeAliase ​ --package -typeHandlers（类型处理器） -objectFactory（对象工厂） -plugins（插件） -environments（环境集合属性对象） ​ --environment（环境子属性对象） ​ ---transactionManager（事务管理） ​ ---dataSource（数据源） -mappers（映射器） ​ --mapper ​ --package properties(属性) 在classpath下定义jdbcConfig.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=xxxx dataSource标签配置 123456&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/dataSource&gt; typeAliases(别名) 自定义别名 123456789&lt;!-- 使用typeAliases配置别名, 它只能配置domain中类的别名--&gt;&lt;typeAliases&gt; &lt;!-- typeAlias用于配置别名. type属性指定的是实体类全限定类名. alias属性指定别名,当指定了别名就不再区分大小写 --&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias type="wzc.domain.User" alias="user"&gt;&lt;/typeAlias&gt; &lt;!-- 批量别名定义, 指定后,该包下的实体类都会注册别名,并且类名就是别名,不再区分大小写 --&gt; &lt;package name="wzc.domain"&gt;&lt;/package&gt;&lt;/typeAliases&gt; mappers(映射器) 使用相对于类路径的资源, 如： 1&lt;mapper resource="wzc/dao/IUserDao.xml" /&gt; 注意: resource属性的资源路径是用/分割 使用mapper接口类路径, 如： 1&lt;mapper class="wzc.dao.UserDao"/&gt; 注意：class属性的类名用.分割. 而且此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 注册指定包下的所有mapper接口, 如： 1&lt;package name="wzc.dao"/&gt; 注意：package标签是用于指定dao接口所在的包,当在typeAliases中指定package name之后就不需要再写mapper以及resource或者class了.]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架学习_01]]></title>
    <url>%2F2019%2F03%2F12%2FMyBatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_01%2F</url>
    <content type="text"><![CDATA[概述MyBatis框架概述​ mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 ​ mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 ​ 采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 JDBC编程分析JDBC操作数据库的步骤 注册驱动 获取连接 获取执行SQL语句对象 执行SQL 获取结果集,封装数据 释放资源 问题分析 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 MyBatis框架快速入门下载MyBatis官网下载Mybatis框架: http://www.mybatis.org/mybatis-3/zh/index.html 搭建MyBatis开发环境 创建maven工程 添加MyBatis坐标 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写User实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package wzc.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable&#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 编写持久层接口IUserDao 1234567891011121314151617package wzc.dao;import wzc.domain.User;import java.util.List;/** * 用户的持久层接口 */public interface IUserDao &#123; /** * 查询所有操作 * @return */ List&lt;User&gt; findAll();&#125; 编写持久层接口的映射文件IUserDao.xml 注意: 此配置文件创建位置必须和持久层接口在相同的包中。 名称必须以持久层接口名称命名，扩展名是.xml. 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="wzc.dao.IUserDao"&gt; &lt;!-- 配置查询所有 --&gt; &lt;select id="findAll" resultType="wzc.domain.User"&gt; SELECT * FROM user &lt;/select&gt;&lt;/mapper&gt; 编写SqlMapConfig.xml配置文件 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置mysql的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置,映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource="wzc/dao/IUserDao.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 编写测试类 123456789101112131415161718192021222324252627282930313233343536373839404142package wzc.test;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import wzc.dao.IUserDao;import wzc.domain.User;import java.io.IOException;import java.io.InputStream;import java.util.List;/** * MyBatis的入门案例 */public class MybatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws IOException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 总结​ 整体项目结构如下: 1234567891011121314151617181920212223─src├─main│ ├─java│ │ └─wzc│ │ ├─dao│ │ │ IUserDao.java│ │ │ │ │ └─domain│ │ User.java│ │ │ └─resources│ │ log4j.properties│ │ SqlMapConfig.xml│ │ │ └─wzc│ └─dao│ IUserDao.xml│ └─test └─java └─wzc └─test MybatisTest.java ​ 通过快速入门示例，我们发现使用mybatis是非常容易的一件事情，因为只需要编写Dao接口并且按照mybatis要求编写两个配置文件，就可以实现功能。远比之前的jdbc方便多了。 基于注解的MyBatis使用 在持久层接口中添加注解 123456789101112131415161718package wzc.dao;import org.apache.ibatis.annotations.Select;import wzc.domain.User;import java.util.List;/** * 用户的持久层接口 */public interface IUserDao &#123; /** * 查询所有操作 * @return */ @Select("SELECT * FROM user") List&lt;User&gt; findAll();&#125; 修改SqlMapConfig.xml 123456&lt;!-- 指定映射配置文件的位置,映射配置文件指的是每个dao独立的配置文件 如果是注解来配置的话,此处应该使用class属性指定被注解的dao全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class="wzc.dao.IUserDao"/&gt;&lt;/mappers&gt; 注意事项 在使用基于注解的Mybatis配置时，必须移除xml的映射配置（IUserDao.xml）,否则会报错。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE基础知识]]></title>
    <url>%2F2019%2F02%2F02%2FJavaEE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Servlet Servlet主要负责接收用户请求HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。 CGI和Servlet 通用网关接口（Common Gateway Interface/CGI）是一种重要的互联网技术，可以让一个客户端，从网页浏览器向服务器上的程序请求数据。 CGI缺点： 每个请求启动一个进程。系统开销大 每个请求加载运行一个CGI程序 需要重复编写处理网络协议的代码 Servlet优点： 只要启动一个进程，加载一个JVM。系统开销小 多个请求做相同处理时，只要加载一个类 所有动态加载的类可以实现对网络协议以及请求解码的共享 能直接和Web服务器交互，还能在各个程序间共享数据，而普通CGI程序不能 注：Fast CGI已经解决了CGI效率上的问题 get和post请求 get请求是从服务器上获得资源，post是向服务器提交数据 get表单数据按name=value的形式添加到action指向的URL，两者用”?”连接，变量间用”&amp;”连接；post是将表单数据放在HTTP协议的请求头或消息体中，传递到action指向URL get有长度限制（最大2048字符），post没有 get参数会显示在地址栏，post不会 get提交表单典型应用是搜索引擎，get方式设计为查询用 转发（Forword）和重定向（Redirect） 转发是服务器行为 1request.getRequestDispatcher("页面地址(不加虚拟路径)").forword(request,response); 重定向是客户端行为 1response.sendRedirect("页面地址(加虚拟路径)"); 转发地址栏不改变，重定向地址栏改变 转发是一次请求，重定向是两次请求 转发可共享request域中数据，用于用户登录（传参给登录后页面）。重定向不能共享数据，用于注销登录返回主页和跳转到其他网站 转发效率高，重定向相率低 Servlet与线程安全 Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题 JSP与Servlet JSP本质上是Servlet MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller） request.getAttribute()和 request.getParameter() getParameter()是获取 POST/GET 传递的参数值，类型是String，用于客户端重定向时，读取提交表单中的值 getAttribute()是获取对象容器中的数据值，类型是Object，可用setAttribute设置成任意对象，使用灵活 JSP九大内置对象 request,response,pageContext,session,application,out,config,page,exception JSP四种作用域 page代表与一个页面相关的对象和属性。 request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 Cookie和Session Cookie 数据保存在客户端(浏览器端)；Session 数据保存在服务器端 Cookie 一般用来保存用户信息；Session 的主要作用就是通过服务端记录用户的状态，典型的场景是购物车 Session 比 Cookie 安全性更高]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发整理]]></title>
    <url>%2F2018%2F10%2F02%2FJava%E5%B9%B6%E5%8F%91%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[进程和线程 进程是程序的一次执行过程，是系统运行程序的基本单位 线程是比进程更小的单位。同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。一个 Java 程序的运行是 main 线程和多个其他线程同时运行。 进程和线程（JVM内存角度） 一个进程中可以有多个线程，多个线程共享进程的堆和方法区（JDK1.8后的元空间），但每个线程有自己的程序计数器、虚拟机栈和本地方法栈 程序计数器为什么私有？ 程序计数器的作用：1.代码流程控制；2.记录当前线程执行位置。 程序计数器私有主要是为了线程切换后能恢复到正确的执行位置 虚拟机栈和本地方法栈为什么私有？ 虚拟机栈：方法在执行时创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息 本地方法栈：与虚拟机栈非常类似，区别：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 为了保证线程中局部变量不被别的线程访问到，虚拟机栈和本地方法栈都是线程私有的。 堆和方法区 堆：线程共享。进程中最大的一块内存，用于存放所有新创建的对象 方法区：线程共享。主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 并发与并行 并发：同一时间段，多个任务都在执行（单位时间内不一定同时执行）（一个人吃两个包子） 并行：单位时间内，多个任务同时执行（两个人吃两个包子） Java是基于并发的 为什么使用多线程？多线程潜在问题？ 线程可以比作轻量级进程，线程间切换和调度的成本低 系统对并发量要求越来越高，多线程并发编程是开发高并发系统的基础 在单核以及多核时代，提高CPU的利用率 可能遇到的问题：内存泄露、上下文切换、死锁还有受限于软硬件的资源浪费问题 线程的生命周期 线程的6种状态： 线程创建后处于NEW（新建）状态，调用start()方法后开始运行，处于READY（可运行）状态，可运行状态的线程获得了CPU时间片（timeslice）后处于RUNNABLE（运行中）状态。当线程执行wait()方法后，线程进入WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能返回运行状态，而TIME_WAITING（超时等待）状态有超时限制，如通过sleep(long millis)方法或wait(long millis)方法，当到达指定时间时线程将返回RUNNABLE状态。当线程调用同步方法synchronized，且没有获取到锁时，线程会进入BLOCKED（阻塞）状态。线程在执行Runnable的run()方法后会进入TERMINATED（终止）状态。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用容器总结（List、Set、Map等）]]></title>
    <url>%2F2018%2F09%2F05%2FJava%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93%EF%BC%88List%E3%80%81Set%E3%80%81Map%E7%AD%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[List, Set, Map List：元素可以不唯一、有序 Set：不允许元素重复 Map：键值对。Key不能重复 ArrayList, LinkedList, Vector 线程安全：ArrayList 和 LinkedList 是不同步的；Vector 是同步的（始于JDK1.0，后被ArrayList取代） 数据结构：ArrayList 底层是Object数组；LinkedList 是双向链表（JDK1.6之前为循环链表，JDK1.7取消了循环） 快速随机访问：通过元素的序号快速获取元素对象(对应于get(int index)方法)。LinkedList 不支持，而ArrayList 支持。 HashMap 和 Hashtable 线程安全：HashMap 是非线程安全的，效率较高；HashTable是线程安全的（始于JDK1.0，内部的方法基本都经过 synchronized 修饰，现在基本被淘汰），效率较低。并发环境下推荐使用 ConcurrentHashMap。 HashMap允许null作为键，这样的键只能有一个；HashTable中若键为null会NPE 初始容量和扩容大小：Hashtable默认初始大小为11，每次扩充变为原来的2n+1；HashMap 默认的初始化大小为16，每次扩充容量变为原来的2n。 数据结构：JDK1.8以后，HashMap在解决哈希冲突时，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable没有这样的机制。 关于Hashtable：Hashtable的第二个t小写是sun的失误，后来sun也确实讨论过这个t的问题，但由于Hashtable是jdk1.0的产物，替换会导致很多老的系统无法兼容，于是sun决定保留小写t HashMap 和 HashSet HashSet 底层就是基于 HashMap 实现的。 HashMap HashSet 实现了Map接口 实现Set接口 存储键值对 仅存储对象 调用 put（）向map中添加元素 调用 add（）方法向Set中添加元素 HashMap使用键（Key）计算Hashcode HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性， HashSet如何检查重复 先计算对象hashcode，与其他加入的对象的hashcode值作比较，如果没有相同的，则会调用equals() 方法检查hashcode相同的对象是否真的相同。如果两者相同，HashSet就不会允许加入操作成功。 ConcurrentHashMap 和 HashMap 线程安全： ConcurrentHashMap（分段锁）：JDK1.7时，对整个桶数组进行了分割分段(Segment)；JDK1.8时摒弃了Segment概念，采用Node数组+链表+红黑树的数据结构实现，并发控制用synchronized和CAS来操作。 Hashtable（同一把锁）：使用 synchronized 来保证线程安全，效率非常低下。 Comparable和Comparator Comparable出自java.lang包，它有一个compareTo()方法 Comparator出自java.util包，它有一个compare()方法 集合的选择 键值选Map，排序选TreeMap，不排序HashMap，线程安全ConcurrentHashMap 存放元素Collection，保证唯一选Set如TreeSet或HashSet，不唯一选ArrayList或LinkedList]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识]]></title>
    <url>%2F2018%2F09%2F02%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[JVM JDK JRE WORA(Write once, run anywhere)从源代码到运行: .java文件-&gt;JDK中的javac编译-&gt;.class文件-&gt;JVM-&gt;机器可执行的二进制机器码 JDK = JRE +编译器( javac) + 工具(javadoc和jdb) JRE(运行时环境) = JVM + Java类库 +Java命令 Java与C++ 指针 多继承 内存管理(GC) 基本数据类型 基本类型 大小(bits) min max 包装类 boolean - - - Boolean char 16 Character byte 8 -128 127 Byte short 16 -215 +215-1 Short int 32 -231 +231-1 Integer long 64 -263 +263-1 Long float 32 IEEE754 IEEE754 Float double 64 IEEE754 IEEE754 Double void - - - Void 重载(overload)和重写(override) overload: 同一个类，方法名必须相同，参数列表不同，返回值和访问修饰符可不同，发生在编译时 override: 子父类中，方法名和参数列表必须相同，返回值范围小于等于父类，抛出异常小于等于父类，访问修饰符大于等于父类（父类方法private时子类不能重写该方法） String, StringBuffer, StringBuilder String: 底层是private final char value[]，因此不可变。线程安全。 StringBuffer, StringBuilder: 底层继承AbstractStringBuilder，没有final修饰，因此可变。 StringBuffer线程安全，效率较低，适用于多线程，出现于jdk1.0。StringBuilder非线程安全，效率比buffer高10-15%，适用于单线程，出现于jdk1.5。 接口与抽象类 接口方法默认public，所有方法在接口中不能实现（Java8开始接口方法可以有默认实现），抽象类可以有非抽象的方法 接口中只能有static、final变量，抽象类不一定 一个类可以实现多个接口，但只能实现一个抽象类 接口方法默认public修饰，为了被重写，抽象方法只可以用除private以外的修饰符修饰 抽象是对类的抽象，接口是对行为的抽象 对象实体与引用 对象实例在堆内存, 对象引用在栈内存 一个对象引用可以指向0或1个对象, 一个对象可以有n个引用指向它 ==和equals（重要） ==: 基本数据类型比较值是否相等, 引用数据类型比较内存地址 equals: 两种情况: 类重写了equals方法, 一般来说, 通过重写equals方法来比较两个对象的内容是否相等 类未重写equals方法, 用Object类中equals方法,即等价于== hashCode与equals（重要）面试题：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？ hashCode() 的作用是获取哈希码（散列码），实际上返回一个int整数。这个哈希码作用是确定该对象在哈希表中的索引位置。 如果两个对象相等，则hashCode一定也相同 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同hashCode值，他们不一定相等 因此，equals方法被覆盖过，则hashCode方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 进程与线程 进程是系统运行程序的基本单位 一个进程在执行过程中可以产生多个线程 线程的基本状态 状态名称 说明 NEW 初始状态，线程被构建，尚未调用start() RUNNABLE 运行状态，操作系统中就绪和运行状态的统称 BLOCKED 阻塞状态，表示线程阻塞于锁 WAITING 等待状态，等待其他线程通知或中断 TIME_WAITING 超时等待状态 TERMINATED 终止状态，表示当前线程执行完毕 final 修饰变量：基本数据类型：初始化后不能改；引用类型：初始化后不能指向其他对象 修饰类：不能被继承。final类中的所有成员方法都会被隐式地指定为final方法 修饰方法：不能被覆盖。类中所有private方法都隐式地指定为final 异常（Exception）与错误（Error） 异常能被程序本身可以处理，错误是无法处理 transient关键字 作用：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。 获取键盘输入的两种方法 Scanner 123Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); BufferedReader 12BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); String s = input.readLine(); IO流 BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。 NIO (New I/O): NIO是一种同步非阻塞的I/O模型 AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-chap4-继承]]></title>
    <url>%2F2018%2F08%2F19%2FJava%E5%9F%BA%E7%A1%80-chap4-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[第四章 继承4.1 继承的概述 继承的好处：1，提高了代码的复用性。 2，让类与类之间产生了关系，给第三个特征多态提供了前提。 格式： 12class 父类&#123;&#125;class 子类 extends 父类&#123;&#125; 4.2继承的特点 继承关系图 继承类型 需要注意：Java不支持多继承，但支持多重继承 什么时候使用继承 继承需要符合的关系是：is-a，父类更通用，子类更具体。当类与类之间存在着所属关系的时候，就定义继承。例：xxx是yyy中的一种。xxx extends yyy 4.3 super关键字 当本类的成员和局部变量同名用this区分。 当子父类中的成员变量同名用super区分父类。 this和super的用法很相似。区别如下： this：代表一个本类对象的引用。 super：代表一个父类空间。 内存图解 4.4 函数覆盖 内存图解 成员函数 当子父类中出现成员函数一模一样的情况，会运行子类的函数。这种现象，称为覆盖操作。这是函数在子父类中的特性。 一模一样： 返回值类型相同 函数名一样 参数列表一样 函数的两个特性：1，重载(overload)。同一个类中。2，覆盖(override)。子类中。覆盖也称为重写，覆写。 覆盖注意事项：1，子类方法覆盖父类方法时，子类权限必须要大于等于父类权限。 2，静态只能覆盖静态，或被静态覆盖。 什么时候使用覆盖操作当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖操作完成。 例：给电话增加来电显示姓名和照片功能： 1234567891011121314151617181920212223242526class Phone&#123; void call() &#123;&#125; void show() &#123; System.out.println("number"); &#125;&#125;class NewPhone extends Phone&#123; void show() &#123; System.out.println("name"); System.out.println("pic"); super.show(); &#125;&#125;class ExtendsDemo3 &#123; public static void main(String[] args) &#123; NewPhone p = new NewPhone(); p.show(); &#125;&#125; 4.5 子类的实例化过程 子父类中的构造函数的特点。在子类构造对象时，发现，访问子类构造函数时，父类也运行了。 上述现象的原因是：在子类的构造函数中第一行有一个默认的隐式语句。super(); 子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数。 为什么子类实例化的时候要访问父类中的构造函数呢？因为子类继承了父类，获取到了父类中的内容(属性)，所以在使用父类内容之前，要先看父类是如何对自己的内容进行初始化的。所以子类在构造对象时，必须访问父类中的构造函数。为了完成这个必须的动作，就在子类的构造函数中加入了super();语句。 如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用父类中哪个构造函数。同时子类构造函数中如果使用this调用了本类构造函数时，那么super就没有了，因为super和this都只能定义在第一行。所以只能有一个。但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。 注意：super语句必须要定义在子类构造函数的第一行。因为父类的初始化动作要先完成。 子类的实例化： 123456789101112131415161718192021222324252627282930313233343536class Fu&#123; Fu() &#123; super(); show(); return; &#125; void show() &#123; System.out.println("fu show"); &#125;&#125;class Zi extends Fu&#123; int num = 8; Zi() &#123; super(); //--&gt;通过super初始化父类内容时，子类的成员变量并未显示初始化。等//super()父类初始化完毕后，才进行子类的成员变量显示初始化。 System.out.println("zi cons run"); return; &#125; void show() &#123; System.out.println("zi show..."+num); &#125;&#125;class ExtendsDemo5 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); &#125;&#125; 内存图解 4.6 final关键字 final可以修饰类，方法，变量。 final修饰的类不可以被继承。即最终类。 final修饰的方法不可以被覆盖。可以让类中被final修饰的方法无法被覆盖。 final修饰的变量是一个常量。只能被赋值一次。 内部类只能访问被final修饰的局部变量。 为什么要用final修饰变量？其实在程序中如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以给该数据起个名称。而且这个变量名称的值不能变化，所以加上final固定。实际开发中，代码一旦涉及到固定不变的值，一定要final化，这叫做专业性。 写法规范 java中变量定义格式xxYyy，首字母小写，之后每个单词首字母大写，与函数名命名规范一样，只是函数带()。 java中常量定义格式XXX_XXX，所有字母大写，中间用下划线_连接。 public static 修饰的称为全局变量 public static final修饰的称为全局常量 4.7 抽象类 抽象类的特点 方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰。 抽象方法必须定义在抽象类中。该类必须也被abstract修饰。 抽象类不可以被实例化。因为调用抽象方法没意义。 抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化。否则，这个子类还是抽象类。 抽象类细节 抽象类中有构造函数吗？有，用于给子类对象进行初始化。 抽象类可以不定义抽象方法吗？可以。但是很少见，目的就是不让该类创建对象。AWT的适配器对象就是这种类。通常这个类中的方法有方法体，但是却没有内容。 例： 12345678abstract class Demo&#123; void show1() &#123;&#125; void show2() &#123;&#125;&#125; 抽象关键字不可以和哪些关键字共存？private 不行。抽象方法必须被子类覆盖，但是私有后子类无法获取方法，因此无法完成对方法的覆盖。 static 不行。如果成员是静态，就不需要创建对象，直接用类名可以调用方法，抽象方法运行无意义，因为抽象方法无方法体。final 不行。矛盾。 抽象类和一般类的区别。相同点：抽象类和一般类都是用来描述事物的，都在内部定义了成员。不同点：1，一般类有足够的信息描述事物。抽象类描述事物的信息有可能不足。2，一般类中不能定义抽象方法，只能定义非抽象方法。 抽象类中可定义抽象方法，同时也可以定义非抽象方法。3，一般类可以被实例化。抽象类不可以被实例化。 抽象类一定是个父类吗？是的。因为需要子类覆盖其方法后才可以对子类实例化。 4.8接口 当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式来定义和表示，就是 接口 interface。 定义接口使用的关键字不是class，是interface。编译后仍为.class文件。 格式 1interface &#123; &#125; 接口中的成员修饰符是固定的。（可省略，编译器会自动加上，但阅读性较差） 成员常量：public static final 成员函数：public abstract 发现接口中的成员都是public的（权限最大） 类与类之间是继承关系，类与接口之间是实现关系。接口的出现将”多继承”通过另一种形式体现出来，即“多实现”。一个类可以实现多个接口。 接口不可以实例化。只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化。否则，这个子类就是一个抽象类。 因为接口中的方法为抽象方法，没有方法体，所以当两个接口方法同名时，子类覆盖方法不会出现不确定性。 接口的出现避免了单继承的局限性 接口与接口之间是继承关系，而且接口可以多继承，因为接口中的方法没有方法体。 例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interface A&#123; public abstract void show();&#125;interface Z&#123; public abstract void show();&#125;class Test implements A,Z//多实现&#123; public void show() &#123;&#125; class Q&#123; public void method() &#123;&#125;&#125;class Test2 extends Q implements A,Z&#123; public void show() &#123;&#125; &#125; interface CC&#123; void show();&#125;interface MM&#123; void method();&#125;interface QQ extends CC,MM//接口与接口之间是继承关系，而且接口可以多继承。因为接口中的方法没有方法体&#123; void function();&#125;class WW implements QQ&#123;//覆盖3个方法。 public void show()&#123;&#125; public void method()&#123;&#125; public void function()&#123;&#125;&#125; 4.8.1 接口的特点 接口是对外暴露的规则(public) 接口是程序的功能扩展 接口的出现降低耦合性 接口可以用来多实现 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口 接口与接口之间可以有继承关系4.8.2 接口与抽象类 共性：都是不断抽取出来的抽象的概念 区别：1，抽象类体现继承关系，一个类只能单继承 接口体现实现关系，一个类可以多实现 2，抽象类是继承，是“IS-A”关系 接口是实现，是“LIKE-A”关系3，抽象类中可以定义非抽象方法，供子类直接使用 接口的方法都是抽象的，接口中的成员都有固定修饰符 4.9 多态多态的定义：某一类事物的多种存在形态 例：动物中猫，狗。 猫这个对象对应的类型是猫类型 1Cat x = new Cat( ); 同时猫也是动物中的一种，也可以把猫称为动物 1Animal y = new Cat( ); 动物是猫和狗具体事物中抽取出来的父类型 父类型引用指向了子类对象 多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容 多态的弊端：前期定义的内容不能调用后期子类的特有内容 多态的前提 必须有关系，继承，实现 要有覆盖 转型 向上转型 12Animal a = new Cat();/*自动类型提升，猫对象提升为动物类型，但是特有功能无法访问 作用是为了限制对子类特有方法的访问，提升代码扩展性。*/ 向下转型 1Cat c = (Cat)a;//作用是为了调用子类中的特有方法。 Instanceof：用于判断对象的具体类型。只能用于引用数据类型判断。 通常在向下转型前用于健壮性的判断。 例： 123456789public static void method(Animal a)//Animal a = new Dog();&#123; a.eat(); if (a instanceof Cat) //instanceof：用于判断对象的具体类型,即判断a是否属于Cat类型 &#123; Cat c = (Cat)a; c.catchMouse(); &#125;&#125; 多态的特点 成员函数 编译时：参考引用型变量所属的类中是否有调用的函数。有，编译通过，没有，编译失败。 运行时：参考的是对象所属的类中是否有调用的函数。 简单说：编译看左边，运行看右边 成员变量 编译时：参考引用型变量所属的类中是否有调用的成员变量，有，编译通过；没有，编译失败。 运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行该所属类中的成员变量。 简单说：编译和运行都参考等号的左边。只看引用变量所属的类啊 内部类内部类的定义：将一个类定义在另一个类的里面，对里面那个类就称为内部类（内置类，嵌套类）。 访问特点 内部类可以直接访问外部类中的成员，包括私有成员 而外部类要访问内部类中的成员必须要建立内部类的对象 直接访问外部类中的内部类中的成员。 12Outer.Inner in = new Outer().new Inner();in.show(); 如果内部类是静态的。 相当于一个外部类 12Outer.Inner in = new Outer.Inner();in.show(); 如果内部类是静态的，成员是静态的。 1Outer.Inner.function();//function()为内部类中的静态方法 如果内部类中定义了静态成员，该内部类也必须是静态的。否则编译不通过 内部类可以存放在局部位置上 内部类在局部位置上只能访问局部中被final修饰的局部变量。 匿名内部类 匿名内部类。就是内部类的简写格式。 必须有前提：内部类必须继承或者实现一个外部类或者接口。 匿名内部类其实就是一个匿名子类对象。 格式：new 父类or接口(){子类内容} 当函数参数是接口类型时，而且接口中的方法不超过三个时，可以用匿名内部类作为实际参数进行传递 例题：注释符内部代码为什么编译失败？ 12345678910111213141516171819202122232425262728293031class Outer&#123; void method() &#123; new Object() &#123; public void show() &#123; System.out.println("show run"); &#125; &#125;.show(); /* Object obj = new Object() &#123; public void show() &#123; System.out.println("show run"); &#125; &#125;; obj.show(); */ &#125;&#125;class InnerClassDemo6 &#123; public static void main(String[] args) &#123; new Outer().method(); &#125;&#125; 因为匿名内部类这个子类对象被向上转型为了Object类型。这样就不能再使用子类的特有方法了。 对象的初始化过程 异常 异常的定义：异常是在运行时期发生的不正常情况 在Java中用类的形式对不正常情况进行了描述和封装对象。描述不正常的情况的类，就称为异常类。 以前正常流程代码和问题处理代码相结合，现在将正常流程代码和问题处理代码分离。提高阅读性。 其实异常就是Java通过面向对象的思想将问题封装成了对象。用异常类对其进行描述。不同的问题用不同的类进行具体的描述。比如角标越界、空指针等等。 异常的体系 Throwable Error 一般不可处理的 通常出现重大问题如：运行的类不存在或者内存溢出等。 不编写针对代码对其处理 Exception 可以处理的 在运行时运行出现的一些情况，可以通过try catch finally Exception和Error的子类名都是以父类名作为后缀]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-chap3-面向对象]]></title>
    <url>%2F2018%2F08%2F19%2FJava%E5%9F%BA%E7%A1%80-chap3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[第三章 面向对象3.1 面向对象概念 面向过程与面向对象举例：大象装进冰箱。 面向过程：打开冰箱。存储大象。关上冰箱。 对于面向过程思想，强调的是过程（动作） 例：C语言 面向对象：冰箱打开。冰箱存储。冰箱关闭。 对于面向对象思想，强调的是对象(实体) 例：C++, Java, C# 特点： 面向对象就是一种常见的思想。符合人们的思考习惯。 面向对象的出现，将复杂的问题简单化。 面向对象的出现，让曾经在过程中的执行者，变成了对象中的指挥者。例：买电脑找电脑专家一起去商城 面向对象语言的三个特征：1，封装2，继承3，多态 3.2 类与对象的关系 类是用Java语言对现实生活中的事物进行的描述通过类的形式来体现 怎么描述呢？对于事物描述通常只关注两方面。一个是属性，一个是行为。 只要明确该事物的属性和行为并定义在类中即可。对象：其实就是该类事物实实在在存在的个体。 类与对象之间的关系？类：事物的描述。对象：该类事物的实例。在Java中通过new来创建的。 定义类其实就是在定义类中的成员。 成员：成员变量&lt;–&gt;属性，成员函数&lt;–&gt;行为。 成员变量和局部变量的区别：1，成员变量定义在类中，整个类中都可以访问。局部变量定义在函数，语句，局部代码块中，只在所属的区域有效。2，成员变量存在于堆内存的对象中，局部变量存在于栈内存的方法中。3，成员变量随着对象的创建而存在，随着对象的消失而消失。局部变量随着所属区域的执行而存在，随着所属区域的结束而释放。4，成员变量都有默认初始化值。局部变量没有默认初始化值。 例： 1234567891011121314151617181920212223class Car&#123; int num; String color; void run() &#123; System.out.println(num+"..."+color); &#125;&#125;class CarDemo&#123; public static void main(String[] args) &#123; //在计算机中创建一个car的实例。通过new关键字。 Car c = new Car();// c就是一个类Car类型的引用变量，指向了该类的对象。 c.num = 4; c.color = "red"; c.run();// 要使用对象中的内容可以通过 对象.成员的形式来完成调用。 &#125;&#125; 对象的内存体现： 基本数据类型参数传递和引用数据类型参数传递 3.3 封装（Encapsulation） 封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。函数、类、框架都是封装体。 封装的好处 将变化隔离 便于使用 提高复用性 提高安全性 封装原则 将不需要对外提供的内容都隐藏起来 把属性都隐藏，提供公共方法对其访问 private关键字 是一个权限修饰符 用于修饰成员（成员变量和成员函数） 用private私有的变量只在本类中有效 常用之一： 将成员变量私有化，对外提供对应的set, get方法对其进行访问。提高对数据访问的安全性 3.4 构造函数 构造函数：构建创造对象时调用的函数 特点 函数名与类名相同 不用定义返回值类型 没有具体的返回值 作用 给对象进行初始化 注意 一个类中如果没有定义过构造函数，那么该类中会有一个默认的空参数构造函数 如果在类中定义了指定的构造函数，那么类中的默认构造函数就没有了 默认构造函数的特点 多个构造函数是以重载的形式存在的 将一个指定类的构造函数私有化private，可以保证不让其他程序创建该类对象 构造函数与一般函数的区别 构造函数：对象创建时，就会调用与之对应的构造函数，对对象进行初始化 一般函数：对象创建后，需要函数功能时才调用 构造函数：对象创建时，调用且只调用一次 一般函数：对象创建后，可以被调用多次 一般函数可以调用构造函数，构造函数不能调用一般函数 构造函数首字母大写，与类名相同；一般函数首字母小写，因此可以通过名称区分 细节：构造函数中可以通过写return的方式来控制输入，但这种情况很少。因为当你new对象时的参数往往来源于客户通过网页形式的输入，如用户名密码等参数。这种情况下通常会有校验，所以不用再在构造函数中进行控制。 对象必须要进行初始化后才能使用 什么时候定义构造函数 在描述事物时，该事物一存在就具备的一些内容，这些内容都定义在构造函数中 构造函数的重载（overload） 一个类中出现多个构造函数时，必须以重载的形式来体现，它可以给不同的对象定义不同的初始化 重载是方法名相同，参数不同。 参数类型顺序不相同的话是重载,相同的话不是 123f(int x, double y),f(int y, double x)//不是重载f(int x, double y),f(double x, int y)//是重载f(int x, double y),f(double y, int x)//是重载 构造函数内存图解（左栈右堆） 3.5 this关键字 特点：this代表其所在函数所属对象的引用。换言之，this代本类对象的引用。简单来说，哪个对象调用了this所在的函数，this就代表哪个对象 什么时候使用this关键字？ 当在函数内需要用到调用该函数的对象时，就用this。例如当成员变量与局部变量重名时，可以用关键字this来区分 this.name = name; this也可以用于在构造函数中调用其他构造函数。 注意：1，一般函数无法调用构造函数。2，this只能定义在构造函数的第一行。因为初始化动作要先执行。 3.6 static（静态）关键字 static关键字 同时也是修饰符，用于修饰成员（成员变量和成员函数） 被修饰后的成员具备以下特点： static修饰的成员随着类的加载而加载 static修饰的成员优先于对象存在 static修饰的成员被所有对象所共享 static修饰的是共享数据，对象中存储的是特有数据 static修饰的成员多了一种调用方式，可以直接被类名调用。格式： 1Person.country//类名.静态成员 使用注意 静态方法只能访问静态成员（非静态既可以访问静态，又可以访问非静态） 静态方法中不可以写this，super关键字 主函数是静态的 成员变量与静态变量 成员变量和静态变量区别： 1，两个变量的生命周期不同。成员变量随着对象的创建而存在，随着对象的被回收而释放。静态变量随着类的加载而存在，随着类的消失而消失。2，调用方式不同。成员变量只能被对象调用。静态变量可以被对象调用，还可以被类名调用。（建议用类名调用，阅读性好）3，别名不同。成员变量也称为实例变量。静态变量也称为类变量。4，数据的存储位置不同。成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据。静态变量数据存储在方法区（共享数据区）的静态区中，所以也叫对象的共享数据。 注：JVM内存划分为五个区域： 寄存器：cpu本地方法区：调用系统底层内容方法区（数据区/共享区/共享数据区）：方法存储栈（stack）：方法调用和局部变量堆（heap）：存储对象 主函数的解释public static void main(String[] args) public：因为权限必须是最大的。 static：虚拟机调用主函数时是不需要对象的，直接用主函数所属类名调用即可。 void：主函数没有具体的返回值。 main：函数名，不是关键字，只是一个JVM识别的固定名字。 String[] args：这是主函数的参数列表，是一个数组类型的参数，而且元素都是字符串类型。 System.out.println(args);//[Ljava.lang.String;@61064425 @右边是哈希值，@左边[表示是数组，L表示long，包名java.lang，存储的是String类型的元素 System.out.println(args.length); //0 表示主函数创建了一个字符串类型的数组，元素个数为0，即new String[0] 静态什么时候使用1，静态变量。 当分析对象中所具备的成员变量的值都是相同的。 这时这个成员就可以被静态修饰。 只要数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，是非静态的。 如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。2，静态变量。 函数是否用静态修饰，就参考该函数功能是否有访问到对象中的特有数据。 简单点说，从源代码看，该功能是否需要访问非静态的成员变量。 如果需要，该功能就是非静态的。 如果不需要，就可以将该功能定义成静态的。当然，也可以定义成非静态，但是非静态需要被对象调用，而仅创建对象调用非静态的没有访问特有数据的方法，该对象的创建时没有意义的。 静态代码块 随着类的加载而执行。而且只执行一次。 作用：用于给类进行初始化。 构造代码块：可以给所有对象进行初始化。 执行顺序（如果有对象）：静态代码块-构造代码块-构造函数 3.7 单例设计模式 设计模式：对问题行之有效的解决方式。其实是一种思想。 单例设计模式（Singleton Pattern）。 解决的问题：就是可以保证一个类在内存中的对象唯一性。 比如对于多个程序使用同一个配置信息对象时，就需要保证该对象的唯一性。 如何保证对象唯一性呢？1，不允许其他程序用new创建该类对象。2，在该类中创建一个本类实例。3，对外提供一个方法，让其他程序可以获取该对象。 步骤：1，私有化该类的构造函数。private2，通过new在本类中创建一个本类对象。3，定义一个公有的方法getInstance(获取实例)，将创建的对象返回。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//饿汉式（实际开发中使用较多）class Single//类一加载，对象就已经存在了。&#123; private static Single s = new Single(); private Single()&#123;&#125; public static Single getInstance() &#123; return s; &#125;&#125;//懒汉式（被多线程并发访问时有可能保证不了对象的唯一性）class Single2//类加载进来，没对象，只有调用了getInstance方法时，才会创建对象。 //延迟加载形式。&#123; private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance() &#123; if (s==null) &#123; s = new Single2(); &#125; return s; &#125;&#125;class SingleDemo&#123; public static void main(String[] args) &#123; Single s1 = Single.getInstance(); Single s2 = Single.getInstance(); System.out.println(s1==s2); &#125;&#125; 单例设计模式-内存图解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-chap2-Java语言基础]]></title>
    <url>%2F2018%2F07%2F27%2FJava%E5%9F%BA%E7%A1%80-chap2-Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[第二章 Java语言基础 2.1 关键字 被赋予特殊含义的单词，关键字都是小写 2.2 标识符 在程序中自定义的一些名称。 由26个英文字母大小写，数字：0-9 符号：_$组成。 定义合法标识符规则：1，数字不可以开头。2，不可以使用关键字。 Java中严格区分大小写。 注意：在起名字时，为了提高阅读性，要尽量有意义 2.3 注释 对于单行和多行注释，被注释的文字，将会被Java编译器忽略，不会被JVM解释执行 对于文档注释，是java特有的注释，其中注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的改程序的说明文档。 注释是一个程序员必须要具有的良好变成习惯。 初学者编程可以养成习惯：先写注释再写代码。例： 12345678910111213141516171819202122232425/*需求：练习一个hello world程序。思路：1，定义一个类，因为Java程序都定义在类中，java程序都是以类的形式存在的，类的形式其实就是一个字节码文件最终体现。2，定义一个主函数。为了让该类可以独立运行。3，因为演示hello world，在控制台上看到该字样，所以需要使用输出语句完成。步骤：1，用class关键字来完成类的定义，并起一个阅读性强的类名。2，主函数：public static void main(String[] args)这是固定格式的。JVM认识。3，使用输出语句：System.out.println("hello world");*/class Demo&#123; //定义一个主函数，为了保证程序的独立运行。 public static void main(String[] args) &#123; System.out.println("Hello World!");//这是输出语句，用于将括号中的数据打印到控制台上，ln可以在数据的结尾处换行。 &#125;&#125; 将自己的思想通过注释先整理出来，再用代码去体现。因为代码仅仅是思想的一种体现形式而已。用于注解说明解释程序的文字就是注释提高了代码阅读性 注释可以进行程序的调试 格式：单行注释//这是许多程序语言通用单行注释 多行注释/*这是许多 程序语言 通用多行注释*/ 文档注释/* 文档注释。 Java语言独有 / 2.4 常量和变量常量 常量表示不能改变的数值。 Java中常量分类：1，整数常量。所有整数2，小数常量。所有小数3，布尔（boolean）型常量。较为特有，只有两个数值。true false。 4，字符常量。将一个数字字母或者符号用单引号（’ ‘）标识。5，字符串常量。讲一个或者多个字符用双引号（” “）标识。6，null常量。只有一个数值就是：null。 对于整数：有四种表现形式。 二进制：0,1，满2进1。byte 字节=8个二进制位（bit位），1KB=1024byte;1MB=1024KB;1GB=2014MB;1TB=1024GB。负数的二进制表现形式：对应的正数二进制取反加1。负数的二进制最高位是1 八进制：0-7，满8进1。用0开头表示。八进制数，其实就是3个二进制位为1个八进制位。如023。 十进制：0-9，满10进1。 十六进制：0-9，A-F，满16进1。用0x开头表示。十六进制数，其实就是4个二进制位为1个十六进制位。如0x23。 一个整数在内存中是用4个字节来表示，如6在内存中表示为0000-0000 0000-0000 0000-0000 0000-0110，-6为6对应的二进制数取反加1，1111-1010 变量 变量的概念： 内存中的一个存储区域 该区域有自己的名称（变量名）和类型（数据类型） 该区域的数据可以在同一类型范围内不断变化 为什么要定义变量： 用来不断的存放同一类型的常量，并可以重复使用 使用变量注意： 变量的作用范围（一对{}之间有效） 初始化值 定义变量的格式： 数据类型 变量名=初始化值; 注：格式是固定的，记住格式，以不变应万变。 理解：变量就如同数学中的未知数。数据类型 Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存总分配了不同大小的内存空间。 整数默认：int 小数默认：double（双精度浮点数） byte 数据类型是8位、有符号的，以二进制补码表示的整数，范围-128(-2^7)~127(2^7-1)，默认值是0； short 数据类型是 16 位、有符号的以二进制补码表示的整数，范围-32768(-2^15)~32767(2^15-1)，默认值是0； int 数据类型是32位、有符号的以二进制补码表示的整数，范围-2,147,483,648(-2^31)~ 2,147,483,647(2^31 - 1)，默认值是0，一般整形变量默认为int类型； long 数据类型是 64 位、有符号的以二进制补码表示的整数，范围-9,223,372,036,854,775,808(-2^63)~ 9,223,372,036,854,775,807(2^63 -1)，默认值是0L（”L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。）； float 数据类型是单精度、32位、符合IEEE 754标准的浮点数，默认值为0.0f； double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数，默认值为0.0d； boolean数据类型表示一位的信息，只有true和false两个取值，默认值为false； char类型是一个单一的16位Unicode（国际统一编码表）字符，范围\u0000（即为0）~\uffff（即为65535），char数据类型可以储存任何字符，可以根据ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）转换成数值后运算，如’A’=65, ‘a’=97； 自动类型转换（也叫隐式类型转换） 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级。 如：int x = 3;byte b = 5; x = x + b; / /此时byte会自动提升为int，并与int相加得出结果 强制类型转换（也叫显式类型转换） 条件是转换的数据类型必须是兼容的。 格式：(type)value type是要强制类型转换后的数据类型如：byte b = 3; b = (byte)(b+4); //强制类型转换。 类型转换的原理 什么时候要用强制类型转换？ 表达式的数据类型自动提升 所有的byte型、short型和char的值将被提升到int型； 如果一个操作数是long型，计算结果就是long型； 如果一个操作数是float型，计算结果就是float型； 如果一个操作数是double型，计算结果就是double型。 分析 System.out.println(‘a’)与System.out.println(‘a’+1)的区别。 面试题： 为什么以下代码运行时报错？ 1234567byte b = 4; //若给定条件b = 3+7; &lt;font color=#FF4500 size=3&gt;3+7是常量&lt;/font&gt;，可以赋值给b，因此run ok。byte b1 = 3;byte b2 = 7;b = b1 + b2; //b1和b2是变量，b为byte类型，如b1+b2的值超过-128~127范围则不能赋予b，因此run会报错可能丢失精度。System.out.println(b); 2.5 运算符算术运算符 有四个：+ - * /% 取余，模运算，如5%2读作“五模以二”，结果为1，结果正负只参考被模数，如5%-2=1，-5%2=-1。 +（连接符） 用于连接字符串，连接符两端都是字符串，如System.out.println(“5+5=”+5+5)输出为5+5=55，若改为System.out.println(“5+5=”+(5+5))输出为5+5=10。++ 自增 a++; //a=a+1;难点： 123456789101112131415int i = 3;i++; //i = i + 1;System.out.println("i= "+i); //i++等价于i=i+1，结果为i=4。int i = 3 ;i = i++; //temp = i; i = i + 1; i = temp; //即先赋值，后运算。System.out.println("i=" + i ); //结果为i=3。 int i = 3 ;i = ++i; //i = i + 1; temp=i; i = temp; //即先运算，后赋值。System.out.println("i=" + i ); //结果为i=4。 自减这里除法/需特别注意，java是强类型语言，两个整数运算后仍是整数。例：123int x = 6370; x = x/1000*1000; System.out.println(x); //这里输出结果是6000，因为6370/1000=6.37,而结果类型为int整型，所以实际结果等于6,6*1000=6000。 赋值运算符 = += 12int a = 4;a+=2; //a = a + 2; 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数 -= 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数 *= 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数 /= 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数 %= 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 面试题： 1 short s = 3;2 s+=4;3 s = s + 4;问：2&amp;3有什么区别？答：short在内存中占两个字节，整数默认类型为int，占4个字节，第3行s为变量，如果s取值较大+4,会超出short范围，则右边s+4不能赋予左边short类型的s。因此若用第三行编译会报错可能精度丢失。若用第2行不会报错，因为第2行+=是加和赋值操作，是一次运算，第3行是两次运算，先求和，再赋值，+=会有一个底层自动强转的过程，而第3行不会做自动强转。其实本题中s+=4;应该等价于s = (short) (s + 4);。 比较运算符 比较运算符的结果都是boolean型，也就是要么是true，要么是false 比较运算符“==”读作等等于，不能误写成“=” 逻辑运算符 用于连接两个boolean类型的表达式 &amp; 运算两边只有有一个是false，结果肯定是false，只有两边都为true，结果才是true | 运算两边只要有一个是true，结果肯定是true，只有两边都为false，结果才是false ^ 异或两边结果如果相同，结果是false，两边的结果不同，结果是true。一个数异或同一个数两次，结果还是这个数。利用该特性可以用于加密 ! 逻辑非运算符。用来反转操作数的逻辑状态 面试题： &amp;&amp; （短路） 只要左边为false，右边不进行运算直接得出false，类似电路中的短路（与&amp;区别，&amp;不管左边什么结果右边都运算），与&amp;运算结果一样，但是运算过程有区别 ||（短路）只要左边为true，右边不进行运算直接得出true，类似电路中的短路（与|区别，|不管左边什么结果右边都运算），与|运算结果一样，但是运算过程有区别###位运算符 位运算是直接对二进制进行运算 位运算可以使运算高效 a &lt;&lt; b = a * 2b; 如3&lt;&lt;2 = 3 * 22 = 12。 a &gt;&gt; b = a / 2b; 无符号右移：数据进行右移时，高位出现的空位，无论原高位是什么，空位都用0补 三元运算符 格式 （条件表达式）? 表达式1 : 表达式2 如果条件为true，运算后的结果是表达式1 如果条件为false，运算后的结果是表达式2 三元运算符就是if else语句的简写格式，当if else运算后，有一个具体的结果时，可以简化为三元运算符 示例： 获取两个数中大数。12int x=3,y=4,z;z = (x&gt;y)?x:y; //z变量存储的就是两个数的大数 2.6 程序流程控制判断结构if 语句 注意：上述三种格式均为单条语句，if(条件表达式)后面紧跟”{“,没有”;”。 大括号”{}”里面的内容根据前面的内容命名，如class后面紧跟的”{}”中的内容叫做类代码块， public static void main后面大括号”{}”中的内容叫做主函数代码块，如果”{}”前面什么都没有，那么”{}”中的内容称为局部代码块。局部代码块的功能：限定局部变量的生命周期（作用域）。 选择结构switch语句 格式：12345678910111213switch(表达式) //只有byte, short, int, char.四种类型可以选择&#123; case 取值1: //注意是冒号&quot;:&quot; 执行语句; break; //如果符合，跳出 case 取值2: 执行语句; break;…… default: //缺省、默认，即其他情况 执行语句; break;&#125; if和switch的区别： if：1,对具体的值进行判断2,对区间的判断3,对运算结果是boolean类型的表达式进行判断 switch（相比if而言并不常用）:1,对具体的值进行判断。对于几个固定值的判断，建议用switch语句，因为switch 语句会将具体答案都加载进内存。2,值的个数通常是固定的 循环结构 （loop）while循环 格式： 1234while (条件表达式)&#123; 执行语句;&#125; Tips: ctrl + c终止控制台运行 do…while循环 格式： 1234do&#123; 执行语句;&#125;while(条件表达式); do…while语句的特点：无论条件是否满足，循环体至少执行一次。 for循环(重要！) 格式： 1234for (初始化表达式; 循环条件表达式（即boolean表达式）; 循环后的操作表达式)&#123; 执行语句; //循环体&#125; for循环执行的次数是在执行前就确定的。 执行顺序：1~8 for和while的特点： 1,for和while可以互换 2,格式上的不同，在使用上有点小区别。 如果需要通过变量来对循环进行控制，该变量只作为循环增量存在时，区别就体现出来了。 什么时候使用循环结构？当对某些代码执行很多次时，使用循环结构完成。当对一个条件进行一次判断时，可以使用if语句。当对一个条件进行多次判断时，可以使用while语句。注意：在使用循环时，一定要明确哪些语句需要参与循环，哪些不需要。循环通常情况下，需要定义条件，需要控制次数。 嵌套语句结构 大圈套小圈思想：对于一种重复的情况中的每一次重复都对应另一种情况的多次重复。 例子： 1234567for (int x = 0;x&lt;3 ;x++ )&#123; for (int y=0;y&lt;4 ;y++ ) &#123; System.out.println("ok"); &#125;&#125; 分析：外循环每循环1次，内循环循环4次，总共循环3*4=12次。 Tips： &quot;：双引号：如输出带双引号的hello world则应输入System.out.print( “&quot;hello world&quot;“); \n：换行符 \t：制表符 \b：退格 \r：按下回车键 在Windows系统中回车符其实是由两个符号组成的：\r\n 在Linux系统中回车符是：\n 其他流程控制语句 break（跳出），continue（继续） break语句应用范围：选择结构和循环结构 continue语句应用范围：循环结构 这两个语句离开应用范围，存在时没有意义的 这两个语句单独存在下面都不可以有语句，因为执行不到 continue语句是结束本次循环继续下次循环 标号的出现，可以让这两个语句作用于制定的范围 2.7 函数函数的定义 函数就是定义在类中的具有特定功能的一段独立小程序 函数也称为方法 函数的格式12345修饰符 返回值类型 函数名（参数类型 形式参数1, 参数类型 形式参数2, ...)&#123; 执行语句; return 返回值;&#125; 函数名写作规范：首字母小写，若有多个单词则除第一个词以外其他词首字母大写 返回值类型：函数运行后的结果的数据类型 参数类型：是形式参数的数据类型 形式参数：是一个变量，用于存储调用函数时传递给函数的实际参数 实际参数：传递给形式参数的具体数值 return：用于结束函数 返回值：该函数运算后的结果，该结果会返回给调用者 函数的特点 定义函数可以将功能代码进行封装 便于对该功能进行复用 函数只有被调用才会被执行 函数的出现提高了代码的复用性 对于函数没有具体返回值的情况，返回值类型用关键字void表示，那么该函数中的return语句如果再最后一行可省略不写 注意：1, 函数中只能调用函数，不可以在函数内部定义函数2, 定义函数时，函数的结果应该返回给调用者，交由调用者处理 函数的应用 例子：需求：定义一个功能，完成两个整数的和的获取 思路：既然定义功能，就是可以用函数来体现 通过两个明确来完成。 明确一：这个功能的结果是什么？是和。是功能的结果，所以该功能的返回值类型是int其实就是在明确函数的返回值类型 明确二：这个功能实现过程中是否需要未知内容参与运算？有，加数和被加数。这就是函数的参数列表（参数的个数，参数的类型）其实就是在明确参数列表 注意：返回值类型和参数类型没有直接关系。 函数示例：12345public static int add(int a,int b)&#123; int sum = a+b; return sum;&#125; 函数的重载（overload） 概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。 特点：与返回值类型无关，只看参数列表java是严谨性语言，如果函数出现调用的不确定性，会编译失败 好处：提高阅读性，优化程序设计 示例： 123456//返回两个整数的和int add(int x,int y)&#123;return x+y;&#125;//返回三个整数的和int add(int x,int y,int z)&#123;return x+y+z;&#125;//返回两个小数的和double add(double x,double y)&#123;return x+y;&#125; 2.8 数组前言 学习任何程序语言，具有容器功能的程序都应作为重点学习。 如果数据出现了对应关系，而且对应关系的一方是有序的数字编号。并作为角标使用，这时就必须要想到数组的使用 数组的定义 概念：同一种类型数据的集合。其实数组就是一个容器 好处：可以自动给数组中的元素从0开始编号，方便操作这些元素 格式1： 元素类型[] 数组名 = new 元素类型[元素个数或数组长度]; 1int[] arr = new int[5]; 使用情况：需要一个容器，但是不明确容器中的具体数据 格式2： 元素类型[] 数组名 = new 元素类型[]{元素，元素，……}; 12int[] arr = new int[]&#123;3,5,1,7&#125;;int[] arr = &#123;3,5,1,7&#125;;//也可以简写为此行 使用情况：需要一个容器，存储已知的具体数据 数组的内存分配及特点 寄存器 本地方法区 方法区 栈内存内存分配：存储的都是局部变量，而且变量所属的作用域一旦结束，该变量就自动释放特点：生命周期短，更新速度快 堆内存内存分配：存储的是数组和对象（其实数组就是对象）。凡是new建立的都在堆中特点：1，每一个实体都有首地址值 （C++中的指针，即Java中的引用） 2，堆内存中的每一个变量都有默认初始化值，根据类型的不同而不同。整数是0，小数0.0f，boolean false，char ‘\u0000’3，垃圾回收机制 数组常见操作 对数组操作最基本的动作就是存和取 核心思想：对角标的操作 遍历：arr.length 表示数组的长度 12345System.out.println("length:"+arr.length); for (int x=0;x&lt;arr.length ;x++ ) &#123; System.out.println("arr["+x+"] = "+arr[x]+";");//输出效果：arr[0] = 89; &#125;//数组的正向遍历 获取最值（最大值，最小值） 排序（选择排序，冒泡排序） 1234567891011121314151617//选择排序public static void selectSort(int[] arr)&#123; for (int x=0;x&lt;arr.length-1 ;x++ )//外循环最后剩余的数不需要比较，故减1 &#123; for (int y=x+1;y&lt;arr.length ;y++ ) &#123; if(arr[x]&gt;arr[y]) &#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; &#125; &#125;&#125; 12345678910111213141516//冒泡排序public static void bubbleSort(int[] arr)&#123; for (int x=0;x&lt;arr.length-1 ;x++ ) &#123; for (int y=0;y&lt;arr.length-1-x ;y++ ) &#123; if (arr[y]&gt;arr[y+1]) &#123; int temp = arr[y]; arr[y] = arr[y+1]; arr [y+1] = temp; &#125; &#125; &#125;&#125; 注意：以上代码面试使用，其实java中已经做好了排序功能，输入以下代码：import java.util.; 然后在主函数中输入*Arrays.sort(arr);** 即可自动对指定数组进行排序，此方法适合实际开发时使用 折半查找（二分查找） 12345678910111213141516171819202122232425public static int halfSearch(int[] arr,int key)&#123; int max,min,mid; min = 0; max = arr.length-1; mid = (max+min)/2; while (arr[mid]!=key) &#123; if (key&gt;arr[mid]) &#123; min = mid + 1; &#125; else if (key&lt;arr[mid]) &#123; max = mid - 1; &#125; if (max&lt;min) &#123; return -1; &#125; mid = (max+min)/2; &#125; return mid;&#125; 注意：以上代码面试使用，其实java中已经做好了二分查找功能，输入以下代码：import java.util.; 然后在程序中输入*Arrays.binarySearch(arr,x);** 即可自动对指定元素x进行二分查找。如果元素x在数组arr[]中存在，返回具体角标；如果不存在，返回的是 -插入点-1。此方法适合实际开发时使用 123Integer.toBinaryString(x); //将十进制数x转化为二进制Integer.toHexString(x);// 将十进制数x转化为十六进制Integer.toOctalString(x);// 将十进制数x转化为八进制 数组中的数组 二维数组[][] 格式1： 1int[][]arr = new int[3][2]; 定义了名称为arr的二维数组表示该二维数组中有3个一维数组每一个一维数组中有2个元素一维数组的名称分别为arr[0],arr[1],arr[2]给第一个一维数组1脚标位赋值为78的写法是：arr[0][1] = 78; 格式2： 1int[][]arr = new int[3][]; 二维数组中有3个一维数组每个一维数组都是默认初始化值null可以对这个三个一维数组分别进行初始化 123456789arr[0] = new int[3];arr[1] = new int[1];arr[2] = new int[2];int[][] arr = new int[3][];System.out.println(arr);//直接打印二维数组 结果：[[I@61064425 @左边[[表示二维数组System.out.println(arr[0]);//直接打印二维数组中的角标0的一维数组 结果：nullSystem.out.println(arr[0][0]);//直接打印二维数组中的角标0的一维数组中角标为0的元素 结果：NullPointerException 二维数组内存图解 ​ 也可以写成 1int[][] arr = &#123;&#123;3,1,7&#125;,&#123;5,8,2,9&#125;,&#123;4,1&#125;&#125;; 编辑器：EditPlus蓝色：关键字红色：Java创建好的类 2.9 基本语法 编写Java程序时，应注意以下几点： 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA学习笔记-chap1-Java概述]]></title>
    <url>%2F2018%2F07%2F19%2FJava%E5%9F%BA%E7%A1%80-chap1-Java%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[第一章 JAVA概述 软件开发软件：一系列按照特定顺序组织的计算机数据和指令的集合系统软件：DOS-Disk Operating System应用软件：扫雷、迅雷、QQ等开发：制作软件，即将数据与指令集合起来 人机交互方式软件的出现实现了人与计算机之间的更好的交互。交互方式：图形化界面（GUI-Graphical User Interface）这种方式简单直观，使用者易于接受，容易上手操作。命令行方式（CLI-Command Line Interface）：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记住一些命令。 1.1计算机语言语言：人与人之间用于沟通的一种方式。计算机语言：人与计算机交流的方式。如果人要与计算机交流，那么就要学习计算机语言。如：C，C++，Java等。 1.2 Java语言概述SUN（Stanford University Network，斯坦福大学网络公司）1995年推出的一门高级程序语言。是一种面向Internet的编程语言。现已被Oracle公司收购。Web应用程序的首选开发语言。简单易学，面向对象，安全可靠，与平台无关的编程语言 1.2.1 Java语言的三种技术架构J2EE(Java 2 Platform Enterprise Edition)企业版J2SE(Java 2 Platform Standard Edition)标准版J2ME(Java 2 Platform Micro Edition)小型版Java5.0版本后，更名为JAVAEE JAVASE JAVAME 1.2.2 Java语言特点：跨平台性可以在Windows、Linux、MAC三个不同的操作系统中执行。 JVM（Java Virtual Machine 虚拟机）：解析Java语言Coding的程序，必须按照系统的种类安装不同版本的JVM 使用任何一门计算机语言的首要任务：环境搭建 1.3 Java语言的环境搭建JRE(Java Runtime Environment Java运行环境)：包括JVM和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。JRE：JVM+类库JDK(Java Development Kit Java开发工具包)：提供给开发人员使用，包含了java开发工具，也包括JRE。所以安装JDK，就不用单独再装JRE。其中开发工具：编译工具(Javac.exe)、打包工具(Jar.exe)等JDK：JRE+JAVA的开发工具(Tools&amp;Tools APIs) 1.3.1 下载JDK下载JDK：http://www.oracle.com (或java.sun.com会自动跳转到www.oracle.com) Downloads - Java for Developers - Java SE 7u3 - JDK Download - Accept License Agreement - jdk - 7u3 - Windows x64 - windows-x64.exebin(binary 二进制)目录下存放的是命令行工具：可执行的程序 图形化界面能做的事情命令行基本都能做，图形化界面的本质是把命令行中的东西封装后对外提供的一种用鼠标就可以操作的便捷图形方式。 打开命令行：win+R - cmd - 输入d: - cd Java - cd jdk（末尾字符可用代替） - cd bin - dir（directory 计算机或程序的目录） 查看目录内容 - javac 运行javac.exe程序 命令行常用指令（1）列出当前目录下的文件以及文件夹 dir - directory（2）创建目录md - make directory（3）打开指定目录命令 CD - change directory （4）回到上一级目录：cd.. （5）回到根目录：cd（6）删除当前指定的子目录命令 rd - remove directory 该命令必须先将文件夹清空后才能执行，早期dos防止用户误删文件夹（7）改变当前盘符命令 c:（8）文件复制命令 copy（9）显示文本文件内容命令 type（10）更改文件名命令 ren - rename（11）删除文件命令 del - delete 如：del*即可将文件夹中内容全部删除 * - 通配符：通通都能匹配的符号 （12）清除屏幕命令 cls - clear screen （13）退出dos命令行 exit （14）有关某个命令的详细信息，请键入help命令名 help 如想要查看cd用法，只要键入help cd回车即可 （15）打开记事本 notepad 当用户打开一个盘符或文件夹，输入的内容在当前目录无法找到时，系统会优先到环境变量中的路径中去寻找是否有该执行程序。设置环境变量：在计算机-高级系统设置-高级-环境变量中设置：Path - 系统中应用程序（exe - executable file可执行文件）所在的路径。 DOS中设置环境变量：set查看某一个环境变量：set 变量名 如：set path临时修改某一环境变量：set 变量名=自定义字符串 如：set path=haha 临时修改，并不会真正修改path，关掉命令行窗口改动取消删除path：set path= 即变量名=没有值添加path：set path=E:\JavaJDK\jdk1.7.0_03\bin;%path% 在原来path上临时加上jdk1.7环境 设置JAVA_HOME: 一是为了方便引用，比如，JDK安装在C:\jdk1.6.0目录里，则设置JAVA_HOME为该目录路径, 那么以后要使用这个路径的时候, 只需输入%JAVA_HOME%即可, 避免每次引用都输入很长的路径串;二则是归一原则, 当JDK路径改变的时候, 仅需更改JAVA_HOME的变量值即可, 否则,就要更改任何用绝对路径引用JDK目录的文档, 要是万一没有改全, 某个程序找不到JDK, 后果是可想而知的—-系统崩溃! 三则是第三方软件会引用约定好的 JAVA_HOME 变量, 不然, 你不能正常使用该软件。在系统环境变量那一栏中点 -&gt; 新建 JAVA_HOME （JAVA_HOME指向的是JDK的安装路径）path 变量path 变量使得我们能够在系统中的任何地方运行java应用程序，比如 javac、java、javah 等等,这就要找到我们安装 JDK 的目录，假设我们的JDK安装在 C:\jdk1.6.0 目录下,那么在 C:\jdk1.6.0\bin 目录下就是我们常用的 java 应用程序,我们就需要把 C:\jdk1.6.0\bin 这个目录加到 path 环境变量里面。classpath 变量classpath 环境变量，是当我们在开发java程序时需要引用别人写好的类时，要让 java 解释器知道到哪里去找这个类。通常，sun 为我们提供了一些额外的丰富的类包，一个是 dt.jar，一个是 tools.jar，这两个 jar 包都位于 C:\jdk1.6.0\lib 目录下，所以通常我们都会把这两个 jar 包加到我们的 classpath 环境变量中 set classpath=.;C:\jdk1.6.0\lib\tools.jar;C:\jdk1.6.0\lib\dt.jar。注意在完成配置环境变量后测试JDK是否安装成功时键入命令：java -version 1.4 Java程序开发体验–Hello World计算机语言全世界通用，与全世界打招呼 编辑。将Java代码编写写到扩展名为.java的文件中。编辑工具：记事本，Eclipse等。 通过javac命令对该java文件进行编译。cmd - cd java文件所在目录 - javac 文件名.java - 生成.class文件 通过java命令执行类文件（启动JVM）。Java 类文件名（不用后缀.class，因为java只能运行类文件）主函数： public static void main(String[] args)（1）主函数可以保证一个类的独立运行。一个类中只能有一个main方法。（2）主函数是所有Java程序运行的入口（所有Java程序从入口开始运行）（3）主函数被JVM执行 记事本编程时，按tab键可以插入制表格，让程序呈阶梯形展现，方便阅读 12345678910Hello Worldclass Demo //前缀加上public后，如类名与.java名称不一致会报错&#123; public static void main(String[] args) //main方法，args=arguments 参数 &#123; System.out.println("hello world"); //println输出后换行，print输出无换行 &#125;&#125; 代码的阅读性相较于功能性来说更加重要，因此写的时候层次清晰，用tab制表格阶梯呈现]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
